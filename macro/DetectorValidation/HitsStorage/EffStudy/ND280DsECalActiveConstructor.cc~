#include <globals.hh>
#include <G4RotationMatrix.hh>
#include <G4VSolid.hh>
#include <G4ThreeVector.hh>
#include <G4Box.hh>
#include <G4PVPlacement.hh>

#include "WAGASCI/ND280WAGASCI.hh"
//#include "ecal/ND280ECalComponents.hh"
//#include "ecal/ND280ECalScintXConstructor.hh"
//#include "ecal/ND280ECalScintYConstructor.hh"
#include "WAGASCI/ND280WAGASCIActiveConstructor.hh"

void ND280WAGASCIActiveConstructor::Init() {
    fLengthX = 0;
    fWidthY = 0;
    fHeightZ = 0;

    //AddConstructor(new ND280ECalScintYConstructor("ScintHoriz", this));
    //AddConstructor(new ND280ECalScintXConstructor("ScintVert", this));
}

G4LogicalVolume* ND280WAGASCIActiveConstructor::GetPiece() {

  //ND280ECalComponents components(GetName());

    
  //0th, always create the world volume. In this simulation, it is already defined
  //0th, create an Air Volume in which the target will be inserted create a big air volume in which WAGASCI will be inserted.



  // -- The Target
  //First, create the volume for WAGASCI Box.
  G4Box * TargetBox = new G4Box("TargetBox",ND280WAGASCI::TargetWidth/2.,ND280WAGASCI::TargetHeight/2.,ND280WAGASCI::TargetThickness/2.);
  //Second, create the Logical Volume for WAGASCI Water Target. Note that latter, an air box should be created.
  G4LogicalVolume * TargetLV = new G4LogicalVolume(TargetBox,Water,"TargetLV");
  //Third, create the Physical Volume for WAGASCI Water Target (rotation, translation, LV, Name, Mother, no boolean operation, copy number);
  new G4PVPlacement(ND280WAGASCI::WAGASCIRotation,ND280WAGASCI::WAGASCIUpstream,TargetLV,"TargetWater",worldLV,false,0); 



  // -- The scintillator layers. An assembly of scintillators

  //1. Layer plan horizontal
  //First, create the volume of a template scintillator:
  G4Box * ScintiPlanBox = new G4Box("ScintiPlanBox",ND280WAGASCI::ScintiPlanLength/2.,ND280WAGASCI::ScintiPlanWidth/2.,ND280WAGASCI::ScintiPlanThickness/2.);
  //Second, create the LV of a template scintillator: 
  G4LogicalVolume * ScintiPlanLV = new G4LogicalVolume(ScintiPlanBox,Scintillator,"ScintiPlanLV");
  //Third, place them <=> Create a physical volume => Create a layer
  int n_bars = ND280WAGASCI::LayerPlanNumberOfScintiHorizontal;
  int nModules=2;//Water and Air
  int nLayers=;//To define
  for(int i=0; i<n_bars;i++){
    G4double scinti_center_position = (ND280WAGASCI::ScintiPlanOffset + i*(ND280WAGASCI::ScintiPlanWidth + ND280WAGASCI::ScintiPlanGap) + ND280WAGASCI::ScintiPlanWidth/2.);
    G4ThreeVector vector_scinti_center_position (ND280WAGASCI::WAGASCIUpstream, scinti_center_position, 0.0*mm);
    new G4PVPlacement(ND280WAGASCI::WAGASCIRotation, vector_scinti_center_position, ScintiPlanLV,Form("LayerPlanHorizontalScinti[%d][%d][%d]",nModules,nLayers,i),TargetLV,false,0); 
  }


  //Define what is Water somewhere.
  //Find the ND280Upgrade Mother LV!
  //Upstream is always water now. Change this
  //Find worldLV name
  //Now, all is defined for only one module. Change this.
  //Create a layer constructor.

    // If bar number needs to increase in the negative direction of
    // the active volume, rotate them by 180 degrees
    G4RotationMatrix* rotation = new G4RotationMatrix();
    
    //First, create a WAGASCI box made of water (for air, see latter with ND280WAGASCI.hh)
    G4LogicalVolume * 

    // Set number and length of bars based on whether this is a side module
    int  n_bars = ND280ECal::DS::NBars;
    double  bar_length = ND280ECal::DS::BarLength;

    // Horizontal Scintillator Layer
    ND280ECalScintYConstructor& layer_horiz 
        = Get<ND280ECalScintYConstructor>("ScintHoriz");
    layer_horiz.SetUp(n_bars,
                      bar_length,
                      ND280ECal::kDS); // nBars, barLength, isX, detector
    G4LogicalVolume* layer_horiz_logical = layer_horiz.GetPiece();
    
     // Perpendicular fScintillator Layer
    ND280ECalScintXConstructor& layer_vert 
        = Get<ND280ECalScintXConstructor>("ScintVert");
    layer_vert.SetUp(n_bars, 
                     bar_length, 
                     ND280ECal::kDS); // nBars, barLength, isX, detector
    G4LogicalVolume* layer_vert_logical = layer_vert.GetPiece();
    
    // Lead Layer
    double lead_x = ( bar_length + (2.0 * ND280ECal::LeadOverhang) );
    double lead_y = ( bar_length + (2.0 * ND280ECal::LeadOverhang) );
    double lead_z = ND280ECal::DS::LeadThickness;
    
    G4LogicalVolume* lead_logical = components.Lead(lead_x, lead_y, lead_z);
    
    // Layer Gap
    double gap_x = bar_length;
    double gap_y = bar_length;
    double gap_z = ND280ECal::DS::LayerGapThickness;
    
    G4LogicalVolume* gap_logical = components.LayerGap(gap_x, gap_y, gap_z);
    
    // ActiveVolume - Logical
    fLengthX = bar_length + (2.0 * ND280ECal::LayerFrameWidth);
    fWidthY = bar_length + (2.0 * ND280ECal::LayerFrameWidth);
    fHeightZ 
        = (ND280ECal::BarHeight +  lead_z + gap_z) * ND280ECal::DS::NLayers;
    
    G4VSolid* vol_solid = new G4Box(GetName(),
                                    (fLengthX/2.0),
                                    (fWidthY/2.0), 
                                    (fHeightZ/2.0));
    G4LogicalVolume* vol_logical
        = new G4LogicalVolume(vol_solid, 
                              FindMaterial("Aluminum"), 
                              GetName());
    
    // Positioning
    // Lead, Gap and Layers are centred in xy
    double delta_z1 = (ND280ECal::BarHeight + lead_z) / 2.0;
    double delta_z2 = (lead_z + gap_z) / 2.0;
    double delta_z3 = (gap_z + ND280ECal::BarHeight) / 2.0;
    
    double z_pos = (-fHeightZ / 2.0) + (ND280ECal::BarHeight / 2.0);
 
    int n_y = 0;
    int n_x = 0;
 
    for(int i = 0; i != ND280ECal::DS::NLayers; ++i) {
        // insert scintillator (horiz layers first)
        if( (i % 2) == 0.0 ) {
            new G4PVPlacement(
                0,    // rotation
                G4ThreeVector(0.0, 0.0, z_pos), // position
                layer_horiz_logical, // logical volume
                layer_horiz.GetName(), // name
                vol_logical, // mother volume
                false,   // no boolean operations
                n_y    // copy number
                );
            ++n_y;
        }
        else {
            new G4PVPlacement(
                rotation,  // rotation
                G4ThreeVector(0.0, 0.0, z_pos), // position
                layer_vert_logical, // logical volume
                layer_vert.GetName(), // name
                vol_logical, // mother volume
                false,   // no boolean operations
                n_x    // copy number
                );
            ++n_x;
        }
  
        z_pos += delta_z1;
  
        // insert lead
        new G4PVPlacement(
            0,    // rotation
            G4ThreeVector(0.0, 0.0, z_pos), // position
            lead_logical, // logical volume
            GetName() + "/Absorber",  // name
            vol_logical, // mother volume
            false,   // no boolean operations
            i    // copy number
            );
  
        z_pos += delta_z2;
   
        // insert gap
        new G4PVPlacement(
            0,    // rotation
            G4ThreeVector(0.0, 0.0, z_pos), // position
            gap_logical, // logical volume
            GetName() + "/LayerGap",  // name
            vol_logical, // mother volume
            false,   // no boolean operations
            i    // copy number
            );
  
        z_pos += delta_z3;
    } 

    return vol_logical;
}
