


//
// Available sensitive detectors (1/2/17):
//
//
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/DsECal/Module/Active/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/DsECal/Module/Active/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/LeftSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/TopLeftBotRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/LeftSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/LeftSide/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/BotLeftTopRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/RightSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/BotLeftTopRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/RightSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/RightSide/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/TopLeftBotRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCUp1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCUp2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCDown1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCDown2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/Target1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/Target2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontUp/ScintVert/Bar --> Included and same name as corresponding physical volume



#include <TH1D.h>
#include <TH2D.h>
#include <TROOT.h>
#include <TTree.h>
#include <TFile.h>
#include <TMath.h>

#include "/atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrackPoint.hh"
#include "/atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrack.hh"
#include "/atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpVertex.hh"
#include "/atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpEvent.hh"

//#include "/Users/davidesgalaberna/Desktop/GENEVA_postdoc/CODE/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrackPoint.hh"
//#include "/Users/davidesgalaberna/Desktop/GENEVA_postdoc/CODE/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrack.hh"
//#include "/Users/davidesgalaberna/Desktop/GENEVA_postdoc/CODE/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpVertex.hh"
//#include "/Users/davidesgalaberna/Desktop/GENEVA_postdoc/CODE/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpEvent.hh"

int GetReacAll(int neut_reaction_mode);
string StringReacAll(int neut_reaction_mode);
//bool IsTargetIn(int targetID,double x,double y,double z);

//bool IsTargetIn(int targetID,double x,double y,double z,
bool IsTargetIn(double x,double y,double z,
		// Target 1
		double vtx_min_x_1,
		double vtx_max_x_1,  
		double vtx_min_y_1, 
		double vtx_max_y_1, 
		double vtx_min_z_1,  
		double vtx_max_z_1 
		// Target 2
		//double vtx_min_x_2,  
		//double vtx_max_x_2,  
		//double vtx_min_y_2, 
		//double vtx_max_y_2,  
		//double vtx_min_z_2,
		//double vtx_max_z_2  
		);

//bool IsFGDIn(int fgdID,double x,double y,double z,
//		// Target 1                                                                                                                                                              
//              double vtx_min_x_1,
//              double vtx_max_x_1,
//              double vtx_min_y_1,
//              double vtx_max_y_1,
//              double vtx_min_z_1,
//              double vtx_max_z_1,
//              // Target 2                                                                                                                                                   
// double vtx_min_x_2,
//              double vtx_max_x_2,
//                double vtx_min_y_2,
//              double vtx_max_y_2,
//              double vtx_min_z_2,
//              double vtx_max_z_2
//              );

void ToFND280UpEvent
(
 const int evtfirst = 0,
 const int nevents = 1,
 
 string tag = "outputs/prova",
 
 string infilename = "../bin/ciao.root",

 // Definition of Fiducial Volume for target thickness=60cm (mm)  
 // Target 1
 const double vtx_min_x_1 = -1150,
 const double vtx_max_x_1 = +1150,  
 const double vtx_min_y_1 = -300, 
 const double vtx_max_y_1 = +300, 
 const double vtx_min_z_1 = -2487,  
 const double vtx_max_z_1 = -487, 
 // Target 2
 //const double vtx_min_x_2 = -1150,  
 //const double vtx_max_x_2 = +1150,  
 //const double vtx_min_y_2 = -300, 
 //const double vtx_max_y_2 = +300, 
 //const double vtx_min_z_2 = +487,  
 //const double vtx_max_z_2 = +2487,  
 // FGD 1        
 //const double vtx_min_x_fgd1 = -1150,
 //const double vtx_max_x_fgd1 = +1150,
 //const double vtx_min_y_fgd1 = -300,
 //const double vtx_max_y_fgd1 = +300,
 //const double vtx_min_z_fgd1 = -2487,
 //const double vtx_max_z_fgd1 = -487,
 // FGD 2
 //const double vtx_min_x_fgd2 = -1150,
 //const double vtx_max_x_fgd2 = +1150,
 //const double vtx_min_y_fgd2 = -300,
 //const double vtx_max_y_fgd2 = +300,
 //const double vtx_min_z_fgd2 = +487,
 //const double vtx_max_z_fgd2 = +2487,


 // Cut 0: Select only CC mode
 const bool doCutCC = true,

 // Cut 1: Select reaction mode
 const bool doCutReac = false,
 const int cut_reac = 0, // 0=CCQE, 1=2p2h, 2=CC1pi, 3=CCcoh, 4=CCDIS, 5=NC
 
 // Cut 2: Vertex cut (inside the Targets and FGDs)
 const bool doCutMater = false,
 const bool doCutVtx = true, 
 
 const bool doCutTarget1 = true, // Select vertex in Target1
 const bool doCutTarget2 = false, // Select vertex in Target2
 const bool doCutFGD1 = true, // Select vertex in FGD1
 const bool doCutFGD2 = false, // Select vertex in FGD2 

 const bool doCutVtxX = false, // width
 const double cut_xmin = 0,
 const double cut_xmax = 0,
 
 const bool doCutVtxZ = false, // length
 const double cut_zmin = 0,
 const double cut_zmax = 0,
 
 // Cut 3: Select PDG
 const bool doCutPDG = true,
 const int cut_pdg = 13, //+211, //+2212; //+13; // +211; //+11
 
 // Cut 4: Select parent ID (0 --> it's primary particle)
 const bool doCutParentID = true,
 const int cut_parentID = 0,

 // Cut 5: Charge cut (TPCs and Target)  
 const bool doCutCharge = true,
 const double cut_charge = 1, // absolute value 
 
 // Cut 6: Length cut (Targets) 
 const bool doCutDLTarget = true, // full length in target and dlyz in tpcs    
 const double cut_length_target_min = 50, //mm  
 
 // Cut 7: DeltaLyz cut (TPCs)
 const bool doCutDLyzTPC = true,
 const double cut_dlyz_tpc_min = 200 //mm  
 
 )
{
  //gROOT->ProcessLine(".L /atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrackPoint.cc+");
  //gROOT->ProcessLine(".L /atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrack.cc+");
  //gROOT->ProcessLine(".L /atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpVertex.cc+");
  //gROOT->ProcessLine(".L /atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpEvent.cc+");







  // Efficiency
  
  // My
  const int NBins_Mom = 33;
  double BinEdges_Mom[NBins_Mom+1] = {0,50,100,150,200,250,300,350,400,450,500,550,600,650,700,750,800,850,900,950,1000,1200,1400,
  				      1600,1800,2000,2500,3000,4000,5000,6000,7000,8000,10000};
  const int NBins_CosTh = 20;
  double BinEdges_CosTh[NBins_CosTh+1] = {-1,-0.9,-0.8,-0.7,-0.6,-0.5,-0.4,-0.3,-0.2,-0.1,0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0};

  // // Final - Muons (Numu)
  // const int NBins_Mom = 33;
  // double BinEdges_Mom[NBins_Mom+1] = {0,50,100,150,200,250,300,350,400,450,500,550,600,650,700,750,800,850,900,950,1000,1200,1400,
  //   				      1600,1800,2000,2500,3000,4000,5000,6000,7000,8000,30000};
  // const int NBins_CosTh = 10;
  // double BinEdges_CosTh[NBins_CosTh+1] = {-1,-0.8,-0.6,-0.4,-0.2,0.0,0.2,0.4,0.6,0.8,1.0};

  // // Final - Pions (Numu)
  // const int NBins_Mom = 21;
  // double BinEdges_Mom[NBins_Mom+1] = {0,100,200,300,400,500,600,700,800,900,1000,1400,
  // 				      1800,2000,2500,3000,4000,5000,6000,7000,8000,30000};
  // const int NBins_CosTh = 10;
  // double BinEdges_CosTh[NBins_CosTh+1] = {-1,-0.8,-0.6,-0.4,-0.2,0.0,0.2,0.4,0.6,0.8,1.0};

  // // Final - Muons (NumuBar)
  // const int NBins_Mom = 21;
  // double BinEdges_Mom[NBins_Mom+1] = {0,100,200,300,400,500,600,700,800,900,1000,1400,
  //  				      1800,2000,2500,3000,4000,5000,6000,7000,8000,30000};
  // const int NBins_CosTh = 8;
  // double BinEdges_CosTh[NBins_CosTh+1] = {-1,-0.6,-0.2,0.0,0.2,0.4,0.6,0.8,1.0};

  // // Final - Electrons (Nue)
  // const int NBins_Mom = 2;
  // double BinEdges_Mom[NBins_Mom+1] = {0,1000,30000};
  // const int NBins_CosTh = 3;
  // double BinEdges_CosTh[NBins_CosTh+1] = {-1,-0.4,0.4,1.0};

  const int NBins_Phi = 20;
  double BinEdges_Phi[NBins_Phi+1];
  double phi_width = 2*TMath::Pi() / NBins_Phi;
  for(int iphi = 0;iphi<NBins_Phi+1;iphi++){
    BinEdges_Phi[iphi] = -TMath::Pi() + iphi*phi_width;
    //cout << BinEdges_Phi[iphi] << ", ";
  }
  
  TH1D *hPhi = new TH1D("hPhi","hPhi",40,-4,4);
  TH1D *hTheta = new TH1D("hTheta","hTheta",40,-4,4);
  
  TH2D *hCosThetaVsMom_FV = new TH2D("hCosThetaVsMom_FV","hCosThetaVsMom_FV",NBins_CosTh,BinEdges_CosTh,NBins_Mom,BinEdges_Mom);
  TH2D *hPhiVsMom_FV = new TH2D("hPhiVsMom_FV","hPhiVsMom_FV",NBins_Phi,BinEdges_Phi,NBins_Mom,BinEdges_Mom);
  TH2D *hThetaVsPhi_FV = new TH2D("hThetaVsPhi_FV","hCosThetaVsMom_FV",NBins_Phi,BinEdges_Phi,NBins_Phi,BinEdges_Phi);
  
  TH2D *hLVsMom_USECalP0D_NoTPC = new TH2D("hLVsMom_USECalP0D_NoTPC","hLVsMom_USECalP0D_NoTPC",200,0,2000,100,0,5000);
  
  //
  
  TH1D *hMom = new TH1D("hMom","hMom",200,0,10000); 
  TH1D *hPDG = new TH1D("hPDG","hPDG",3000,-500,2500);
  
  // Vertex
  TH2D *hVtxOut_XY = new TH2D("hVtxOut_XY","hVtxOut_XY",400,-2000,2000,400,-2000,2000); // mm 
  TH2D *hVtxOut_XZ = new TH2D("hVtxOut_XZ","hVtxOut_XZ",400,-2000,2000,800,-4000,4000); // mm  
  TH2D *hVtxOut_YZ = new TH2D("hVtxOut_YZ","hVtxOut_YZ",400,-2000,2000,800,-4000,4000); // mm   
  TH1D *hVtxOut_X = new TH1D("hVtxOut_X","hVtxOut_X",400,-2000,2000); // mm  
  TH1D *hVtxOut_Y = new TH1D("hVtxOut_Y","hVtxOut_Y",400,-2000,2000); // mm    
  TH1D *hVtxOut_Z = new TH1D("hVtxOut_Z","hVtxOut_Z",800,-4000,4000); // mm 
  TH2D *hVtx_XY = new TH2D("hVtx_XY","hVtx_XY",400,-2000,2000,400,-2000,2000); // mm 
  TH2D *hVtx_XZ = new TH2D("hVtx_XZ","hVtx_XZ",400,-2000,2000,800,-4000,4000); // mm  
  TH2D *hVtx_YZ = new TH2D("hVtx_YZ","hVtx_YZ",400,-2000,2000,800,-4000,4000); // mm  
  TH1D *hVtx_X = new TH1D("hVtx_X","hVtx_X",400,-2000,2000); // mm  
  TH1D *hVtx_Y = new TH1D("hVtx_Y","hVtx_Y",400,-2000,2000); // mm    
  TH1D *hVtx_Z = new TH1D("hVtx_Z","hVtx_Z",800,-4000,4000); // mm 

  TH1D *hCut = new TH1D("hCut","hCut",10,0,10);
  hCut->GetXaxis()->SetBinLabel(1,"Evt gener");
  hCut->GetXaxis()->SetBinLabel(2,"Evt FV");
  hCut->GetXaxis()->SetBinLabel(3,"Evt CC");
  hCut->GetXaxis()->SetBinLabel(4,"Evt Mode");
  hCut->GetXaxis()->SetBinLabel(5,"Trk PDG");
  hCut->GetXaxis()->SetBinLabel(6,"Trk ParID");
  hCut->GetXaxis()->SetBinLabel(7,"Trk Charge");
  hCut->GetXaxis()->SetBinLabel(8,"Trk L(Targ)");
  hCut->GetXaxis()->SetBinLabel(9,"Trk Lyz(TPC)");

  TH1D *hNuReacFV = new TH1D("hNuReacFV","hNuReacFV",6,0,6);
  hNuReacFV->GetXaxis()->SetBinLabel(1,"CCQE");
  hNuReacFV->GetXaxis()->SetBinLabel(2,"2p2h");
  hNuReacFV->GetXaxis()->SetBinLabel(3,"CC1pi");
  hNuReacFV->GetXaxis()->SetBinLabel(4,"CCcoh");
  hNuReacFV->GetXaxis()->SetBinLabel(5,"CCDIS");
  hNuReacFV->GetXaxis()->SetBinLabel(6,"NC");

  //
  
  TH1D *hTimeTarg1_DsECal    = new TH1D("hTimeTarg1_DsECal", "hTimeTarg1_DsECal", 100,0,100); 
  TH1D *hTimeTarg1_BrlECal   = new TH1D("hTimeTarg1_BrlECal","hTimeTarg1_BrlECal",100,0,100); 
  TH1D *hTimeTarg1_P0DECal   = new TH1D("hTimeTarg1_P0DECal","hTimeTarg1_P0DECal",100,0,100); 
  TH1D *hTimeTarg1_USECalP0D = new TH1D("hTimeTarg1_USECalP0D","hTimeTarg1_USECalP0D",100,0,100); 

  TH1D *hTimeTarg1_ForwTPC1 = new TH1D("hTimeTarg1_ForwTPC1","hTimeTarg1_ForwTPC1",100,0,100); 
  TH1D *hTimeTarg1_ForwTPC2 = new TH1D("hTimeTarg1_ForwTPC2","hTimeTarg1_ForwTPC2",100,0,100); 
  TH1D *hTimeTarg1_ForwTPC3 = new TH1D("hTimeTarg1_ForwTPC3","hTimeTarg1_ForwTPC3",100,0,100); 

  TH1D *hTimeTarg1_TPCUp1   = new TH1D("hTimeTarg1_TPCUp1","hTimeTarg1_TPCUp1",100,0,100); 
  TH1D *hTimeTarg1_TPCUp2   = new TH1D("hTimeTarg1_TPCUp2","hTimeTarg1_TPCUp2",100,0,100); 
  TH1D *hTimeTarg1_TPCDown1 = new TH1D("hTimeTarg1_TPCDown1","hTimeTarg1_TPCDown1",100,0,100); 
  TH1D *hTimeTarg1_TPCDown2 = new TH1D("hTimeTarg1_TPCDown2","hTimeTarg1_TPCDown2",100,0,100); 
    
  TH1D *hTimeTarg1_ToFTopUp   = new TH1D("hTimeTarg1_ToFTopUp", "hTimeTarg1_ToFTopUp", 100,0,100); 
  TH1D *hTimeTarg1_ToFBotUp   = new TH1D("hTimeTarg1_ToFBotUp", "hTimeTarg1_ToFBotUp", 100,0,100); 
  TH1D *hTimeTarg1_ToFRightUp = new TH1D("hTimeTarg1_ToFRightUp", "hTimeTarg1_ToFRightUp", 100,0,100); 
  TH1D *hTimeTarg1_ToFLeftUp  = new TH1D("hTimeTarg1_ToFLeftUp", "hTimeTarg1_ToFLeftUp", 100,0,100); 
  TH1D *hTimeTarg1_ToFBackUp  = new TH1D("hTimeTarg1_ToFBackUp", "hTimeTarg1_ToFBackUp", 100,0,100); 
  TH1D *hTimeTarg1_ToFFrontUp = new TH1D("hTimeTarg1_ToFFrontUp", "hTimeTarg1_ToFFrontUp", 100,0,100); 

  TH1D *hTimeTarg1_ToFTopDown   = new TH1D("hTimeTarg1_ToFTopDown", "hTimeTarg1_ToFTopDown", 100,0,100); 
  TH1D *hTimeTarg1_ToFBotDown   = new TH1D("hTimeTarg1_ToFBotDown", "hTimeTarg1_ToFBotDown", 100,0,100); 
  TH1D *hTimeTarg1_ToFRightDown = new TH1D("hTimeTarg1_ToFRightDown", "hTimeTarg1_ToFRightDown", 100,0,100); 
  TH1D *hTimeTarg1_ToFLeftDown  = new TH1D("hTimeTarg1_ToFLeftDown", "hTimeTarg1_ToFLeftDown", 100,0,100); 
  TH1D *hTimeTarg1_ToFBackDown  = new TH1D("hTimeTarg1_ToFBackDown", "hTimeTarg1_ToFBackDown", 100,0,100); 
  TH1D *hTimeTarg1_ToFFrontDown = new TH1D("hTimeTarg1_ToFFrontDown", "hTimeTarg1_ToFFrontDown", 100,0,100); 

  //

  TH2D *hForwTPC1TrkPtXY = new TH2D("hForwTPC1TrkPtXY","hForwTPC1TrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hForwTPC1TrkPtXZ = new TH2D("hForwTPC1TrkPtXZ","hForwTPC1TrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hForwTPC1TrkPtYZ = new TH2D("hForwTPC1TrkPtYZ","hForwTPC1TrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hForwTPC2TrkPtXY = new TH2D("hForwTPC2TrkPtXY","hForwTPC2TrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hForwTPC2TrkPtXZ = new TH2D("hForwTPC2TrkPtXZ","hForwTPC2TrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hForwTPC2TrkPtYZ = new TH2D("hForwTPC2TrkPtYZ","hForwTPC2TrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hForwTPC3TrkPtXY = new TH2D("hForwTPC3TrkPtXY","hForwTPC3TrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hForwTPC3TrkPtXZ = new TH2D("hForwTPC3TrkPtXZ","hForwTPC3TrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hForwTPC3TrkPtYZ = new TH2D("hForwTPC3TrkPtYZ","hForwTPC3TrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCUp1TrkPtXY = new TH2D("hTPCUp1TrkPtXY","hTPCUp1TrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCUp1TrkPtXZ = new TH2D("hTPCUp1TrkPtXZ","hTPCUp1TrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCUp1TrkPtYZ = new TH2D("hTPCUp1TrkPtYZ","hTPCUp1TrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCUp2TrkPtXY = new TH2D("hTPCUp2TrkPtXY","hTPCUp2TrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCUp2TrkPtXZ = new TH2D("hTPCUp2TrkPtXZ","hTPCUp2TrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCUp2TrkPtYZ = new TH2D("hTPCUp2TrkPtYZ","hTPCUp2TrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCDown1TrkPtXY = new TH2D("hTPCDown1TrkPtXY","hTPCDown1TrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCDown1TrkPtXZ = new TH2D("hTPCDown1TrkPtXZ","hTPCDown1TrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCDown1TrkPtYZ = new TH2D("hTPCDown1TrkPtYZ","hTPCDown1TrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCDown2TrkPtXY = new TH2D("hTPCDown2TrkPtXY","hTPCDown2TrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCDown2TrkPtXZ = new TH2D("hTPCDown2TrkPtXZ","hTPCDown2TrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hTPCDown2TrkPtYZ = new TH2D("hTPCDown2TrkPtYZ","hTPCDown2TrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hDsECalTrkPtXY = new TH2D("hDsECalTrkPtXY","hDsECalTrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hDsECalTrkPtXZ = new TH2D("hDsECalTrkPtXZ","hDsECalTrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hDsECalTrkPtYZ = new TH2D("hDsECalTrkPtYZ","hDsECalTrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hP0DECalTrkPtXY = new TH2D("hP0DECalTrkPtXY","hP0DECalTrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hP0DECalTrkPtXZ = new TH2D("hP0DECalTrkPtXZ","hP0DECalTrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hP0DECalTrkPtYZ = new TH2D("hP0DECalTrkPtYZ","hP0DECalTrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hBrlECalTrkPtXY = new TH2D("hBrlECalTrkPtXY","hBrlECalTrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hBrlECalTrkPtXZ = new TH2D("hBrlECalTrkPtXZ","hBrlECalTrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hBrlECalTrkPtYZ = new TH2D("hBrlECalTrkPtYZ","hBrlECalTrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hUSECalP0DTrkPtXY = new TH2D("hUSECalP0DTrkPtXY","hUSECalP0DTrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hUSECalP0DTrkPtXZ = new TH2D("hUSECalP0DTrkPtXZ","hUSECalP0DTrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hUSECalP0DTrkPtYZ = new TH2D("hUSECalP0DTrkPtYZ","hUSECalP0DTrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  
  TH2D *hToFUpTrkPtXY = new TH2D("hToFUpTrkPtXY","hToFUpTrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hToFUpTrkPtXZ = new TH2D("hToFUpTrkPtXZ","hToFUpTrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hToFUpTrkPtYZ = new TH2D("hToFUpTrkPtYZ","hToFUpTrkPtYZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hToFDownTrkPtXY = new TH2D("hToFDownTrkPtXY","hToFDownTrkPtXY",200,-2000,+2000,200,-4000,+4000);
  TH2D *hToFDownTrkPtXZ = new TH2D("hToFDownTrkPtXZ","hToFDownTrkPtXZ",200,-2000,+2000,200,-4000,+4000);
  TH2D *hToFDownTrkPtYZ = new TH2D("hToFDownTrkPtYZ","hToFDownTrkPtYZ",200,-2000,+2000,200,-4000,+4000);

  //
  
  // Check the inputs
  if(!doCutTarget1 && !doCutTarget2 && !doCutFGD1 && !doCutFGD2){
    cout << endl;
    cout << "You are not selecting interactions in any target !!!" << endl;
    cout << endl;
    exit(1);
  }

  TFile *finput = new TFile(infilename.c_str(),"READ");
  TTree *tinput = (TTree*) finput->Get("ND280upEvents");
  
  TND280UpEvent *nd280UpEvent = new TND280UpEvent();  
  tinput->SetBranchAddress("Event",&nd280UpEvent);
  
  int NTreeEntries = tinput->GetEntries();  
  int evtlasttree = NTreeEntries-1;
  int Nentries = -999;

  cout << endl;
  cout << "# of entries in the Tree: " << NTreeEntries << endl;
  cout << "last tree event ID: " << evtlasttree << endl;
  cout << "first event ID: " << evtfirst << endl;
  cout << endl;
  
  if(evtfirst > evtlasttree){
    cout << endl;
    cout << "first selection evt ID > first evt ID of tree:" << endl;
    cout << " - # of tree events = " << NTreeEntries << endl;
    cout << " - last tree event = " << evtlasttree << endl;
    cout << " - first event = " << evtfirst << endl;
    cout << "Exit!!!" << endl;
    cout << endl;
    exit(1);
  }
  else if(NTreeEntries < (evtfirst+nevents)){
    
    Nentries = NTreeEntries - evtfirst;
    
    cout << endl;
    cout << "WARNING:" << endl;
    cout << "first evt ID + # of events > tot # of tree events:" << endl;
    cout << " - # of tree events = " << NTreeEntries << endl;
    cout << " - # of events to run = " << nevents << endl;
    cout << " - first event = " << evtfirst << endl;
    cout << "Set # of events to run to " << Nentries;
    cout << endl;
  }
  else{
    Nentries = nevents;    
  }
  
  int EntryLast = evtfirst+Nentries-1;
  
  cout << endl;
  cout << "First event = " << evtfirst << endl;
  cout << "Last event = " << EntryLast << endl;
  cout << "# of events = " << Nentries << endl;
  cout << endl;


  for(int ievt=evtfirst;ievt<=EntryLast;ievt++){ // get last entry
    
    tinput->GetEntry(ievt);
    
    if(!(ievt%1000)){
      cout << "Event " << ievt << endl;
    }

    bool PassCutVtx = false; // if at least 1 vertex does it
    bool PassCutReac = false; // cut on reaction mode
    bool PassCutCC = false;  // reject NC

    double NuEtrue = 0.;
    double NuEvis = 0.;
    double NuEreco = 0.;
    
    int NVertices = nd280UpEvent->GetNVertices();
    if(NVertices>1){
      cerr << endl;
      cerr << "More than 1 vertex is not yet supported!!!" << endl;
      cerr << endl;
      exit(1);
    }

    TND280UpVertex *nd280UpVertex;

    double time_vtx = -999;
    for(int ivtx=0;ivtx<NVertices;ivtx++){
      nd280UpVertex = nd280UpEvent->GetVertex(ivtx);
      //TND280UpVertex *nd280UpVertex = new TND280UpVertex();
      //nd280UpEvent->GetVertex(ivtx)->Copy(*nd280UpVertex);
      
      TND280UpTrack *nd280UpVtxTrkIn1 = nd280UpVertex->GetInTrack(0);
      TND280UpTrack *nd280UpVtxTrkIn2 = nd280UpVertex->GetInTrack(1);
      int pdg_vtxtrk1 = nd280UpVtxTrkIn1->GetPDG();
      int pdg_vtxtrk2 = nd280UpVtxTrkIn2->GetPDG();      

      int reacmode = abs(nd280UpVertex->GetReacMode());
      int reacmode_all = GetReacAll(reacmode);
      int cut_reac_all = GetReacAll(cut_reac); 

      time_vtx = nd280UpVertex->GetTime();
      
      //
      // Cut 0: don't consider NC events
      //

      if(doCutCC && reacmode_all==5) PassCutCC = false; 
      else PassCutCC = true;

      //
      // Cut 1: true reaction mode
      //

      if(doCutReac && reacmode_all==cut_reac) PassCutReac = true;
      else PassCutReac = true;
      	
      //
      // Cut 2: vtx in FV
      //
      
      if(fabs(pdg_vtxtrk1)==12 || 
	 fabs(pdg_vtxtrk1)==14 ||
	 fabs(pdg_vtxtrk1)==16 
	 ){
	double mom_vtxtrk1 = nd280UpVtxTrkIn1->GetInitMom().Mag();
	//hNuMom->Fill(mom_vtxtrk1);
	//hNuPDG->Fill(pdg_vtxtrk1);
	NuEtrue = mom_vtxtrk1;
      }
      else if(fabs(pdg_vtxtrk2)==12 || 
	      fabs(pdg_vtxtrk2)==14 ||
	      fabs(pdg_vtxtrk2)==16 
	      ){
	double mom_vtxtrk2 = nd280UpVtxTrkIn2->GetInitMom().Mag();
	//hNuMom->Fill(mom_vtxtrk2);
	//hNuPDG->Fill(pdg_vtxtrk2);	
	NuEtrue = mom_vtxtrk2;
      }       
      
      //
      // Cut on the target material:
      // - O16 --> 1000080160
      // - C12 --> 1000060120
      // - proton --> 2212
      // - neutron --> 2112
      //
      //if(doCutMater){
      //if(pdg_vtxtrk1 == 1000080160 || // O16
      //pdg_vtxtrk2 == 1000080160 || // O16
      //pdg_vtxtrk1 == 1000060120 || // C12
      //pdg_vtxtrk2 == 1000060120 || // C12
      //pdg_vtxtrk1 == 2212 || // proton
      //pdg_vtxtrk2 == 2212 || // proton
      //pdg_vtxtrk1 == 2112 || // neutron
      //pdg_vtxtrk2 == 2112  // neutron
      //){ 
      //
      // Interaction in target materials 
      //
      //}
      //else{
      //continue;
      //}	
      //}
      
      if(doCutVtx){
	
	bool FillVtxInFV = false;
	
	double VtxX = nd280UpVertex->GetPosition().X();
	double VtxY = nd280UpVertex->GetPosition().Y();
	double VtxZ = nd280UpVertex->GetPosition().Z();

	// Require only 1 target as FV
	int NumOfFVTargets = 0;
	if(doCutTarget1) NumOfFVTargets++;
	if(doCutTarget2) NumOfFVTargets++;
	if(doCutFGD1)    NumOfFVTargets++;
	if(doCutFGD2)    NumOfFVTargets++;
	if(NumOfFVTargets!=1){
	  cerr << endl;
	  cerr << "More than one target are FV!!!" << endl;
	  cerr << endl;
	  exit(1);
	}

	// Target 1 FV
	if(doCutTarget1 || doCutTarget2 || doCutFGD1 || doCutFGD2 ){
	  PassCutVtx = IsTargetIn(VtxX,VtxY,VtxZ,
				  // Target 1
				  vtx_min_x_1,
				  vtx_max_x_1,  
				  vtx_min_y_1, 
				  vtx_max_y_1, 
				  vtx_min_z_1,  
				  vtx_max_z_1 
				  );
	  FillVtxInFV = PassCutVtx;
	}
       	// don't apply this cut
	else if(!doCutTarget1){ // && !doCutTarget2 && !doCutFGD1 && !doCutFGD2){
	  PassCutVtx = true;
	  FillVtxInFV = true;
	}
	else{
          cerr << endl;
          cerr << "You can select only 1 target/fgd at a time!!!" << endl;
          cerr << endl;
          exit(1);
        }
	
	// Cut on X vertex position
	if(doCutVtxX){
	  if( VtxX < cut_xmin || 
	      VtxX > cut_xmax ){
	    PassCutVtx = false;
	    FillVtxInFV = false;
	  }
	}	  
	// Cut on Z vertex position
	if(doCutVtxZ){
	  if( VtxZ < cut_zmin || 
	      VtxZ > cut_zmax ){
	    PassCutVtx = false;
	    FillVtxInFV = false;
	  }
	}
		
	//
	// Fill this way because only 1 vertex per event!!!
	//
	if(!FillVtxInFV){
	  hVtxOut_XY->Fill(VtxX,VtxY);
	  hVtxOut_XZ->Fill(VtxX,VtxZ);
	  hVtxOut_YZ->Fill(VtxY,VtxZ);
	  hVtxOut_X->Fill(VtxX);
	  hVtxOut_Y->Fill(VtxY);
	  hVtxOut_Z->Fill(VtxZ);
	}
	else{
          hVtx_XY->Fill(VtxX,VtxY);
          hVtx_XZ->Fill(VtxX,VtxZ);
	  hVtx_YZ->Fill(VtxY,VtxZ);
          hVtx_X->Fill(VtxX);
	  hVtx_Y->Fill(VtxY);
	  hVtx_Z->Fill(VtxZ);
	}
      }
      
      if(doCutVtx){
	if(PassCutVtx) 
	  hNuReacFV->Fill(reacmode_all);
      }
      else 
	hNuReacFV->Fill(reacmode_all);

      //nd280UpVertex->PrintVertex();
      //delete nd280UpVtxTrkIn1;
      //nd280UpVtxTrkIn1 = 0;
      //delete nd280UpVtxTrkIn2;
      //nd280UpVtxTrkIn2 = 0;
      //delete nd280UpVertex;
      //nd280UpVertex = 0;

    } // end loop over vertices

    hCut->Fill(0.);

    if(doCutVtx && !PassCutVtx) continue;
    //NTotEvtFV++; // Pass Cut 2: at least 1 vertex in FV + reaction mode
    hCut->Fill(1.); 
    
    if(doCutCC && !PassCutCC) continue;
    //NTotCC++;
    hCut->Fill(2.);
    
    if(doCutReac && !PassCutReac) continue;
    //NTotVtxReac++;
    hCut->Fill(3.);  

    
    int NTracks = nd280UpEvent->GetNTracks();
    //cout << "# of tracks = " << NTracks << " --> PDG: ";
    
    for(int itrk=0;itrk<NTracks;itrk++){
      TND280UpTrack *nd280UpTrack = nd280UpEvent->GetTrack(itrk);
      //nd280UpTrack->PrintTrack();

      int trkID = nd280UpTrack->GetTrackID();
      int parentID = nd280UpTrack->GetParentID();
      int pdg = nd280UpTrack->GetPDG();
      double charge = nd280UpTrack->GetCharge();
      double ekin = nd280UpTrack->GetInitKinEnergy();
      double mom = nd280UpTrack->GetInitMom().Mag(); 
    
      double dirX = nd280UpTrack->GetInitMom().X() / mom;
      double dirY = nd280UpTrack->GetInitMom().Y() / mom;
      double dirZ = nd280UpTrack->GetInitMom().Z() / mom;
      double phi = atan2(dirY,dirX);
      double cosphi = cos(phi);
      //double phi = atan(dirY/dirX);
      //double cosphi = dirY;
      //double phi = acos(cosphi); 
      if(cosphi<-1 || cosphi>+1){
	cerr << endl;
	cerr << "cosphi = " << cosphi << " !!!" << endl;
	cerr << endl;
	exit(1);
      }
      double costheta = dirZ;
      double theta = acos(costheta);
      if(costheta<-1 || costheta>+1){
	cerr << endl;
	cerr << "costheta = " << costheta << " !!!" << endl;
	cerr << endl;
	exit(1);
      }

      double SDlength = nd280UpTrack->GetSDLength();      
      if(SDlength<0.){ 
	cout << "SDlength = " << SDlength << " !!!" << endl;
	exit(1);
      }
   
      double length_target1  = nd280UpTrack->GetLengthTarget1();
      double length_target2  = nd280UpTrack->GetLengthTarget2();
      double length_fgd1     = nd280UpTrack->GetLengthFGD1();
      double length_fgd2     = nd280UpTrack->GetLengthFGD2();
      double length_tpcup1   = nd280UpTrack->GetLengthTPCUp1();
      double length_tpcup2   = nd280UpTrack->GetLengthTPCUp2();
      double length_tpcdown1 = nd280UpTrack->GetLengthTPCDown1();
      double length_tpcdown2 = nd280UpTrack->GetLengthTPCDown2();
      double length_forwtpc1 = nd280UpTrack->GetLengthForwTPC1();
      double length_forwtpc2 = nd280UpTrack->GetLengthForwTPC2();
      double length_forwtpc3 = nd280UpTrack->GetLengthForwTPC3();      
      
      double length_dsecal    = nd280UpTrack->GetLengthDsECal();
      double length_brlecal   = nd280UpTrack->GetLengthBrlECal();
      double length_p0decal   = nd280UpTrack->GetLengthP0DECal();
      double length_usecalp0d = nd280UpTrack->GetLengthUSECalP0D();
      double edep_dsecal      = nd280UpTrack->GetEdepDsECal();
      double edep_brlecal     = nd280UpTrack->GetEdepBrlECal();
      double edep_p0decal     = nd280UpTrack->GetEdepP0DECal();
      double edep_usecalp0d   = nd280UpTrack->GetEdepUSECalP0D();
 
      double lyz_tpcup1     = nd280UpTrack->GetLyzTPCUp1();
      double lyz_tpcup2     = nd280UpTrack->GetLyzTPCUp2();
      double lyz_tpcdown1   = nd280UpTrack->GetLyzTPCDown1();
      double lyz_tpcdown2   = nd280UpTrack->GetLyzTPCDown2();
      double lyz_forwtpc1   = nd280UpTrack->GetLyzForwTPC1();
      double lyz_forwtpc2   = nd280UpTrack->GetLyzForwTPC2();
      double lyz_forwtpc3   = nd280UpTrack->GetLyzForwTPC3();      

      //
      // Cut 3: particle PDG
      //
      if(doCutPDG){
      	if(pdg!=cut_pdg) continue;
      }
      hCut->Fill(4.);
      
      //
      // Cut 4: parent ID = 0
      //
      if(doCutParentID){
      	if(parentID!=cut_parentID) continue;
      }
      hCut->Fill(5.);
      
      //
      // Cut 5: particle charge
      //
      if(doCutCharge){
      	if(abs(charge)!=cut_charge) continue;
      }
      hCut->Fill(6.);
      
      int NPoints = nd280UpTrack->GetNPoints();    
      
      // Loop over the track points      
      
      //cout << "Evt " << ievt << " : " << "NPoints = " << NPoints << endl;   
      
      double EntrForwTPC1X = 0; double EntrForwTPC1Y = 0; double EntrForwTPC1Z = 0; double EntrForwTPC1Mom = -999;
      double EntrForwTPC2X = 0; double EntrForwTPC2Y = 0; double EntrForwTPC2Z = 0; double EntrForwTPC2Mom = -999;
      double EntrForwTPC3X = 0; double EntrForwTPC3Y = 0; double EntrForwTPC3Z = 0; double EntrForwTPC3Mom = -999;
      double EntrTPCUp1X = 0; double EntrTPCUp1Y = 0; double EntrTPCUp1Z = 0; double EntrTPCUp1Mom = -999;
      double EntrTPCUp2X = 0; double EntrTPCUp2Y = 0; double EntrTPCUp2Z = 0; double EntrTPCUp2Mom = -999;
      double EntrTPCDown1X = 0; double EntrTPCDown1Y = 0; double EntrTPCDown1Z = 0; double EntrTPCDown1Mom = -999;
      double EntrTPCDown2X = 0; double EntrTPCDown2Y = 0; double EntrTPCDown2Z = 0; double EntrTPCDown2Mom = -999;
      double EntrDsECalX = 0;   double EntrDsECalY = 0;   double EntrDsECalZ = 0;   double EntrDsECalMom = -999;
      double EntrBrlECalX = 0;  double EntrBrlECalY = 0;  double EntrBrlECalZ = 0;  double EntrBrlECalMom = -999;
      double EntrP0DECalX = 0;  double EntrP0DECalY = 0;  double EntrP0DECalZ = 0;  double EntrP0DECalMom = -999;
      double EntrUSECalP0DX = 0;double EntrUSECalP0DY = 0;double EntrUSECalP0DZ = 0;double EntrUSECalP0DMom = -999;
      double EntrToFUpX = 0;    double EntrToFUpY = 0;    double EntrToFUpZ = 0;   double EntrToFUpMom = -999;
      double EntrToFDownX = 0;  double EntrToFDownY = 0;  double EntrToFDownZ = 0; double EntrToFDownMom = -999;

      double ExForwTPC1X = 0;   double ExForwTPC1Y = 0;   double ExForwTPC1Z = 0;   double ExForwTPC1Mom = 999999999;
      double ExForwTPC2X = 0;   double ExForwTPC2Y = 0;   double ExForwTPC2Z = 0;   double ExForwTPC2Mom = 999999999;
      double ExForwTPC3X = 0;   double ExForwTPC3Y = 0;   double ExForwTPC3Z = 0;   double ExForwTPC3Mom = 999999999;
      double ExTPCUp1X = 0;   double ExTPCUp1Y = 0;   double ExTPCUp1Z = 0;   double ExTPCUp1Mom = 999999999;
      double ExTPCUp2X = 0;   double ExTPCUp2Y = 0;   double ExTPCUp2Z = 0;   double ExTPCUp2Mom = 999999999;
      double ExTPCDown1X = 0;   double ExTPCDown1Y = 0;   double ExTPCDown1Z = 0;   double ExTPCDown1Mom = 999999999;
      double ExTPCDown2X = 0;   double ExTPCDown2Y = 0;   double ExTPCDown2Z = 0;   double ExTPCDown2Mom = 999999999;
      double ExDsECalX = 0;     double ExDsECalY = 0;     double ExDsECalZ = 0;     double ExDsECalMom = 999999999;
      double ExBrlECalX = 0;    double ExBrlECalY = 0;    double ExBrlECalZ = 0;    double ExBrlECalMom = 999999999;
      double ExP0DECalX = 0;    double ExP0DECalY = 0;    double ExP0DECalZ = 0;    double ExP0DECalMom = 999999999;
      double ExUSECalP0DX = 0;  double ExUSECalP0DY = 0;  double ExUSECalP0DZ = 0;  double ExUSECalP0DMom = 999999999;      
      double ExToFUpX = 0;    double ExToFUpY = 0;    double ExToFUpZ = 0;   double ExToFUpMom = 999999999;
      double ExToFDownX = 0;  double ExToFDownY = 0;  double ExToFDownZ = 0; double ExToFDownMom = 999999999;
 
      double LastX = 0;         double LastY = 0;         double LastZ = 0; 

      double time_first = -999;   double time_curr = -999;  double time_prev = -999;

      
      for(int ipt=0;ipt<NPoints;ipt++){
	TND280UpTrackPoint *nd280UpTrackPoint = nd280UpTrack->GetPoint(ipt);	
	double length = nd280UpTrackPoint->GetStepLength();
       	double PtX = nd280UpTrackPoint->GetPostPosition().X();
       	double PtY = nd280UpTrackPoint->GetPostPosition().Y();
       	double PtZ = nd280UpTrackPoint->GetPostPosition().Z();	
	double PtMom = nd280UpTrackPoint->GetMomentum().Mag();
	//string volname = nd280UpTrackPoint->GetPhysVolName();
	string volname = nd280UpTrackPoint->GetLogVolName();
	
	double timediff = -999;

	time_curr = nd280UpTrackPoint->GetTime();
	
	if(time_curr < time_prev){
	  cout << "time_curr = " << time_curr << endl;
	  cout << "time_prev = " << time_prev << endl;
	  exit(1);
	}
	if(ipt==0) time_first = time_curr; // store time of first trk point 
	
	LastX = PtX;
	LastY = PtY;
	LastZ = PtZ;
				  
	if( (volname.find("DsECal") != string::npos) &&  
		 (volname.find("Bar")    !=string::npos)  ){
	  
	  timediff = time_curr - time_first;
	  hTimeTarg1_DsECal->Fill(timediff);
	  
	  if(PtMom>EntrDsECalMom){
	    EntrDsECalMom = PtMom;
	    EntrDsECalX = PtX;
	    EntrDsECalY = PtY;
	    EntrDsECalZ = PtZ;
	  }	
	  if(PtMom<ExDsECalMom){
	    ExDsECalMom = PtMom;
	    ExDsECalX = PtX;
	    ExDsECalY = PtY;
	    ExDsECalZ = PtZ;
	  }
	}
	else if( (volname.find("P0DECal") != string::npos) &&  
		 (volname.find("Bar")    !=string::npos)  ){

	  timediff = time_curr - time_first;
	  hTimeTarg1_P0DECal->Fill(timediff);

	  if(PtMom>EntrP0DECalMom){
	    EntrP0DECalMom = PtMom;
	    EntrP0DECalX = PtX;
	    EntrP0DECalY = PtY;
	    EntrP0DECalZ = PtZ;
	  }	
	  if(PtMom<ExP0DECalMom){
	    ExP0DECalMom = PtMom;
	    ExP0DECalX = PtX;
	    ExP0DECalY = PtY;
	    ExP0DECalZ = PtZ;
	  }
	}
	else if( (volname.find("BrlECal") != string::npos) &&  
		 (volname.find("Bar")    !=string::npos)  ){
	  
	  timediff = time_curr - time_first;
	  hTimeTarg1_BrlECal->Fill(timediff);

	  if(PtMom>EntrBrlECalMom){
	    EntrBrlECalMom = PtMom;
	    EntrBrlECalX = PtX;
	    EntrBrlECalY = PtY;
	    EntrBrlECalZ = PtZ;
	  }	
	  if(PtMom<ExBrlECalMom){
	    ExBrlECalMom = PtMom;
	    ExBrlECalX = PtX;
	    ExBrlECalY = PtY;
	    ExBrlECalZ = PtZ;
	  }
	}
	else if( (volname.find("P0D/USECal") != string::npos) &&  
		 (volname.find("Bar")    !=string::npos)  ){
	  
	  timediff = time_curr - time_first;
	  hTimeTarg1_USECalP0D->Fill(timediff);
	  
	  if(PtMom>EntrUSECalP0DMom){
	    EntrUSECalP0DMom = PtMom;
	    EntrUSECalP0DX = PtX;
	    EntrUSECalP0DY = PtY;
	    EntrUSECalP0DZ = PtZ;
	  }	
	  if(PtMom<ExUSECalP0DMom){
	    ExUSECalP0DMom = PtMom;
	    ExUSECalP0DX = PtX;
	    ExUSECalP0DY = PtY;
	    ExUSECalP0DZ = PtZ;
	  }
	}
	else if( (volname.find("ForwTPC1") != string::npos) &&
		 ( (volname.find("MM")     !=string::npos)  || 
		   (volname.find("Half")   !=string::npos)   )  
		 ){

	  timediff = time_curr - time_first;
	  hTimeTarg1_ForwTPC1->Fill(timediff);
	  
	  if(PtMom>EntrForwTPC1Mom){
	    EntrForwTPC1Mom = PtMom;
	    EntrForwTPC1X = PtX;
	    EntrForwTPC1Y = PtY;
	    EntrForwTPC1Z = PtZ;
	  }
	  if(PtMom<ExForwTPC1Mom){
	    ExForwTPC1Mom = PtMom;
	    ExForwTPC1X = PtX;
	    ExForwTPC1Y = PtY;
	    ExForwTPC1Z = PtZ;
	  }
	}
	else if( (volname.find("ForwTPC2") != string::npos) &&
		 ( (volname.find("MM")     !=string::npos)  || 
		   (volname.find("Half")   !=string::npos)   )
		 ){

	  timediff = time_curr - time_first;
	  hTimeTarg1_ForwTPC2->Fill(timediff);

	  if(PtMom>EntrForwTPC2Mom){
	    EntrForwTPC2Mom = PtMom;
	    EntrForwTPC2X = PtX;
	    EntrForwTPC2Y = PtY;
	    EntrForwTPC2Z = PtZ;
	  }
	  if(PtMom<ExForwTPC2Mom){
	    ExForwTPC2Mom = PtMom;
	    ExForwTPC2X = PtX;
	    ExForwTPC2Y = PtY;
	    ExForwTPC2Z = PtZ;
	  }
	}
	else if( (volname.find("ForwTPC3") != string::npos) &&
		 ( (volname.find("MM")     !=string::npos)  ||
		   (volname.find("Half")   !=string::npos)   )
		 ){

	  timediff = time_curr - time_first;
	  hTimeTarg1_ForwTPC3->Fill(timediff);

	  if(PtMom>EntrForwTPC3Mom){
	    EntrForwTPC3Mom = PtMom;
	    EntrForwTPC3X = PtX;
	    EntrForwTPC3Y = PtY;
	    EntrForwTPC3Z = PtZ;
	  }
	  if(PtMom<ExForwTPC3Mom){
	    ExForwTPC3Mom = PtMom;
	    ExForwTPC3X = PtX;
	    ExForwTPC3Y = PtY;
	    ExForwTPC3Z = PtZ;
	  }
	}
	else if( (volname.find("TPCUp1") != string::npos) ){

	  timediff = time_curr - time_first;
	  hTimeTarg1_TPCUp1->Fill(timediff);

	  if(PtMom>EntrTPCUp1Mom){
	    EntrTPCUp1Mom = PtMom;
	    EntrTPCUp1X = PtX;
	    EntrTPCUp1Y = PtY;
	    EntrTPCUp1Z = PtZ;
	  }
	  if(PtMom<ExTPCUp1Mom){
	    ExTPCUp1Mom = PtMom;
	    ExTPCUp1X = PtX;
	    ExTPCUp1Y = PtY;
	    ExTPCUp1Z = PtZ;
	  }
	}
	else if( (volname.find("TPCUp2") != string::npos) ){

	  timediff = time_curr - time_first;
	  hTimeTarg1_TPCUp2->Fill(timediff);

	  if(PtMom>EntrTPCUp2Mom){
	    EntrTPCUp2Mom = PtMom;
	    EntrTPCUp2X = PtX;
	    EntrTPCUp2Y = PtY;
	    EntrTPCUp2Z = PtZ;
	  }
	  if(PtMom<ExTPCUp2Mom){
	    ExTPCUp2Mom = PtMom;
	    ExTPCUp2X = PtX;
	    ExTPCUp2Y = PtY;
	    ExTPCUp2Z = PtZ;
	  }
	}
	else if( (volname.find("TPCDown1") != string::npos) ){

	  timediff = time_curr - time_first;
	  hTimeTarg1_TPCDown1->Fill(timediff);

	  if(PtMom>EntrTPCDown1Mom){
	    EntrTPCDown1Mom = PtMom;
	    EntrTPCDown1X = PtX;
	    EntrTPCDown1Y = PtY;
	    EntrTPCDown1Z = PtZ;
	  }
	  if(PtMom<ExTPCDown1Mom){
	    ExTPCDown1Mom = PtMom;
	    ExTPCDown1X = PtX;
	    ExTPCDown1Y = PtY;
	    ExTPCDown1Z = PtZ;
	  }
	}
	else if( (volname.find("TPCDown2") != string::npos) ){
	  
	  timediff = time_curr - time_first;
	  hTimeTarg1_TPCDown2->Fill(timediff);

	  if(PtMom>EntrTPCDown2Mom){
	    EntrTPCDown2Mom = PtMom;
	    EntrTPCDown2X = PtX;
	    EntrTPCDown2Y = PtY;
	    EntrTPCDown2Z = PtZ;
	  }
	  if(PtMom<ExTPCDown2Mom){
	    ExTPCDown2Mom = PtMom;
	    ExTPCDown2X = PtX;
	    ExTPCDown2Y = PtY;
	    ExTPCDown2Z = PtZ;
	  }
	}

	else if( (volname.find("ToF") != string::npos) && 
		 (volname.find("Up") != string::npos) ){
	  
	  if(volname.find("TopUp") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFTopUp->Fill(timediff);
	  }
	  else if(volname.find("BotUp") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFBotUp->Fill(timediff);
	  }
	  else if(volname.find("RightUp") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFRightUp->Fill(timediff);
	  }
	  else if(volname.find("LeftUp") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFLeftUp->Fill(timediff);
	  }
	  else if(volname.find("BackUp") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFBackUp->Fill(timediff);
	  }
	  else if(volname.find("FrontUp") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFFrontUp->Fill(timediff);
	  }
	  
	  if(PtMom>EntrToFUpMom){
	    EntrToFUpMom = PtMom;
	    EntrToFUpX = PtX;
	    EntrToFUpY = PtY;
	    EntrToFUpZ = PtZ;
	  }
	  if(PtMom<ExToFUpMom){
	    ExToFUpMom = PtMom;
	    ExToFUpX = PtX;
	    ExToFUpY = PtY;
	    ExToFUpZ = PtZ;
	  }
	}



	else if( (volname.find("ToF") != string::npos) && 
		 (volname.find("Down") != string::npos) ){

	  if(volname.find("TopDown") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFTopDown->Fill(timediff);
	  }
	  else if(volname.find("BotDown") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFBotDown->Fill(timediff);
	  }
	  else if(volname.find("RightDown") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFRightDown->Fill(timediff);
	  }
	  else if(volname.find("LeftDown") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFLeftDown->Fill(timediff);
	  }
	  else if(volname.find("BackDown") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFBackDown->Fill(timediff);
	  }
	  else if(volname.find("FrontDown") != string::npos){
	    timediff = time_curr - time_first;
	    hTimeTarg1_ToFFrontDown->Fill(timediff);
	  }
	  
	  if(PtMom>EntrToFDownMom){
	    EntrToFDownMom = PtMom;
	    EntrToFDownX = PtX;
	    EntrToFDownY = PtY;
	    EntrToFDownZ = PtZ;
	  }
	  if(PtMom<ExToFDownMom){
	    ExToFDownMom = PtMom;
	    ExToFDownX = PtX;
	    ExToFDownY = PtY;
	    ExToFDownZ = PtZ;
	  }
	}
	
	//delete nd280UpTrackPoint;
	//nd280UpTrackPoint = 0;
	
	time_prev = time_curr;

      } // loop over points

     //
      // Fill entrance detector points
      //
      if(EntrForwTPC1Mom>0.){
	hForwTPC1TrkPtXY->Fill(EntrForwTPC1X,EntrForwTPC1Y);
	hForwTPC1TrkPtXZ->Fill(EntrForwTPC1X,EntrForwTPC1Z);
	hForwTPC1TrkPtYZ->Fill(EntrForwTPC1Y,EntrForwTPC1Z);	  
      }
      if(ExForwTPC1Mom<9999999.){
	hForwTPC1TrkPtXY->Fill(ExForwTPC1X,ExForwTPC1Y);
      	hForwTPC1TrkPtXZ->Fill(ExForwTPC1X,ExForwTPC1Z);
      	hForwTPC1TrkPtYZ->Fill(ExForwTPC1Y,ExForwTPC1Z);	  
      }
      //
      if(EntrForwTPC2Mom>0.){
	hForwTPC2TrkPtXY->Fill(EntrForwTPC2X,EntrForwTPC2Y);
	hForwTPC2TrkPtXZ->Fill(EntrForwTPC2X,EntrForwTPC2Z);
	hForwTPC2TrkPtYZ->Fill(EntrForwTPC2Y,EntrForwTPC2Z);	  
      }
      if(ExForwTPC2Mom<9999999.){
	hForwTPC2TrkPtXY->Fill(ExForwTPC2X,ExForwTPC2Y);
      	hForwTPC2TrkPtXZ->Fill(ExForwTPC2X,ExForwTPC2Z);
      	hForwTPC2TrkPtYZ->Fill(ExForwTPC2Y,ExForwTPC2Z);	  
      }
      // 
      if(EntrForwTPC3Mom>0.){
	hForwTPC3TrkPtXY->Fill(EntrForwTPC3X,EntrForwTPC3Y);
	hForwTPC3TrkPtXZ->Fill(EntrForwTPC3X,EntrForwTPC3Z);
	hForwTPC3TrkPtYZ->Fill(EntrForwTPC3Y,EntrForwTPC3Z);	  
      }
      if(ExForwTPC3Mom<9999999.){
	hForwTPC3TrkPtXY->Fill(ExForwTPC3X,ExForwTPC3Y);
      	hForwTPC3TrkPtXZ->Fill(ExForwTPC3X,ExForwTPC3Z);
      	hForwTPC3TrkPtYZ->Fill(ExForwTPC3Y,ExForwTPC3Z);	  
      }
      //
      if(EntrTPCUp1Mom>0.){
	hTPCUp1TrkPtXY->Fill(EntrTPCUp1X,EntrTPCUp1Y);
	hTPCUp1TrkPtXZ->Fill(EntrTPCUp1X,EntrTPCUp1Z);
	hTPCUp1TrkPtYZ->Fill(EntrTPCUp1Y,EntrTPCUp1Z);	  
      }
      if(ExTPCUp1Mom<9999999.){
	hTPCUp1TrkPtXY->Fill(ExTPCUp1X,ExTPCUp1Y);
      	hTPCUp1TrkPtXZ->Fill(ExTPCUp1X,ExTPCUp1Z);
      	hTPCUp1TrkPtYZ->Fill(ExTPCUp1Y,ExTPCUp1Z);	  
      }
      //
      if(EntrTPCUp2Mom>0.){
	hTPCUp2TrkPtXY->Fill(EntrTPCUp2X,EntrTPCUp2Y);
	hTPCUp2TrkPtXZ->Fill(EntrTPCUp2X,EntrTPCUp2Z);
	hTPCUp2TrkPtYZ->Fill(EntrTPCUp2Y,EntrTPCUp2Z);	  
      }
      if(ExTPCUp2Mom<9999999.){
	hTPCUp2TrkPtXY->Fill(ExTPCUp2X,ExTPCUp2Y);
      	hTPCUp2TrkPtXZ->Fill(ExTPCUp2X,ExTPCUp2Z);
      	hTPCUp2TrkPtYZ->Fill(ExTPCUp2Y,ExTPCUp2Z);	  
      }
      //
      if(EntrTPCDown1Mom>0.){
	hTPCDown1TrkPtXY->Fill(EntrTPCDown1X,EntrTPCDown1Y);
	hTPCDown1TrkPtXZ->Fill(EntrTPCDown1X,EntrTPCDown1Z);
	hTPCDown1TrkPtYZ->Fill(EntrTPCDown1Y,EntrTPCDown1Z);	  
      }
      if(ExTPCDown1Mom<9999999.){
	hTPCDown1TrkPtXY->Fill(ExTPCDown1X,ExTPCDown1Y);
      	hTPCDown1TrkPtXZ->Fill(ExTPCDown1X,ExTPCDown1Z);
      	hTPCDown1TrkPtYZ->Fill(ExTPCDown1Y,ExTPCDown1Z);	  
      }
      //
      if(EntrTPCDown2Mom>0.){
	hTPCDown2TrkPtXY->Fill(EntrTPCDown2X,EntrTPCDown2Y);
	hTPCDown2TrkPtXZ->Fill(EntrTPCDown2X,EntrTPCDown2Z);
	hTPCDown2TrkPtYZ->Fill(EntrTPCDown2Y,EntrTPCDown2Z);	  
      }
      if(ExTPCDown2Mom<9999999.){
	hTPCDown2TrkPtXY->Fill(ExTPCDown2X,ExTPCDown2Y);
      	hTPCDown2TrkPtXZ->Fill(ExTPCDown2X,ExTPCDown2Z);
      	hTPCDown2TrkPtYZ->Fill(ExTPCDown2Y,ExTPCDown2Z);	  
      }
      //
      if(EntrDsECalMom>0.){
	hDsECalTrkPtXY->Fill(EntrDsECalX,EntrDsECalY);
	hDsECalTrkPtXZ->Fill(EntrDsECalX,EntrDsECalZ);
	hDsECalTrkPtYZ->Fill(EntrDsECalY,EntrDsECalZ);	  
      }
      if(ExDsECalMom<9999999.){
	hDsECalTrkPtXY->Fill(ExDsECalX,ExDsECalY);
	hDsECalTrkPtXZ->Fill(ExDsECalX,ExDsECalZ);
	hDsECalTrkPtYZ->Fill(ExDsECalY,ExDsECalZ);	  
      }
      //
      if(EntrBrlECalMom>0.){
	hBrlECalTrkPtXY->Fill(EntrBrlECalX,EntrBrlECalY);
	hBrlECalTrkPtXZ->Fill(EntrBrlECalX,EntrBrlECalZ);
	hBrlECalTrkPtYZ->Fill(EntrBrlECalY,EntrBrlECalZ);	  
      }
      if(ExBrlECalMom<9999999.){
	hBrlECalTrkPtXY->Fill(ExBrlECalX,ExBrlECalY);
	hBrlECalTrkPtXZ->Fill(ExBrlECalX,ExBrlECalZ);
	hBrlECalTrkPtYZ->Fill(ExBrlECalY,ExBrlECalZ);	  
      }
      //
      if(EntrP0DECalMom>0.){
	hP0DECalTrkPtXY->Fill(EntrP0DECalX,EntrP0DECalY);
	hP0DECalTrkPtXZ->Fill(EntrP0DECalX,EntrP0DECalZ);
	hP0DECalTrkPtYZ->Fill(EntrP0DECalY,EntrP0DECalZ);	  
      }
      if(ExP0DECalMom<9999999.){
	hP0DECalTrkPtXY->Fill(ExP0DECalX,ExP0DECalY);
	hP0DECalTrkPtXZ->Fill(ExP0DECalX,ExP0DECalZ);
	hP0DECalTrkPtYZ->Fill(ExP0DECalY,ExP0DECalZ);	  
      }
      //
      if(EntrUSECalP0DMom>0.){
	hUSECalP0DTrkPtXY->Fill(EntrUSECalP0DX,EntrUSECalP0DY);
	hUSECalP0DTrkPtXZ->Fill(EntrUSECalP0DX,EntrUSECalP0DZ);
	hUSECalP0DTrkPtYZ->Fill(EntrUSECalP0DY,EntrUSECalP0DZ);	  
      }
      if(ExUSECalP0DMom<9999999.){
	hUSECalP0DTrkPtXY->Fill(ExUSECalP0DX,ExUSECalP0DY);
	hUSECalP0DTrkPtXZ->Fill(ExUSECalP0DX,ExUSECalP0DZ);
	hUSECalP0DTrkPtYZ->Fill(ExUSECalP0DY,ExUSECalP0DZ);	  
      }
      //

      if(EntrToFUpMom>0.){
	hToFUpTrkPtXY->Fill(EntrToFUpX,EntrToFUpY);
	hToFUpTrkPtXZ->Fill(EntrToFUpX,EntrToFUpZ);
	hToFUpTrkPtYZ->Fill(EntrToFUpY,EntrToFUpZ);	  
      }
      if(ExToFUpMom<9999999.){
	hToFUpTrkPtXY->Fill(ExToFUpX,ExToFUpY);
	hToFUpTrkPtXZ->Fill(ExToFUpX,ExToFUpZ);
	hToFUpTrkPtYZ->Fill(ExToFUpY,ExToFUpZ);	  
      }

      if(EntrToFDownMom>0.){
	hToFDownTrkPtXY->Fill(EntrToFDownX,EntrToFDownY);
	hToFDownTrkPtXZ->Fill(EntrToFDownX,EntrToFDownZ);
	hToFDownTrkPtYZ->Fill(EntrToFDownY,EntrToFDownZ);	  
      }
      if(ExToFDownMom<9999999.){
	hToFDownTrkPtXY->Fill(ExToFDownX,ExToFDownY);
	hToFDownTrkPtXZ->Fill(ExToFDownX,ExToFDownZ);
	hToFDownTrkPtYZ->Fill(ExToFDownY,ExToFDownZ);	  
      }
      
      /////
      
      
      //delete nd280UpTrack;
      //nd280UpTrack = 0;

    } // end loop over tracks
    
    //cout << endl;

    delete nd280UpEvent;    
    nd280UpEvent = 0;
  } // end loop over events
  
   
  // Write output file
  TString outfilename = TString::Format("%s_Evt%d_NEvt%d.root",tag.c_str(),evtfirst,nevents);
  TFile *out = new TFile(outfilename.Data(),"RECREATE");
  //
  hVtx_X->Write();
  hVtx_Y->Write();
  hVtx_Z->Write();
  hVtx_XY->Write();
  hVtx_XZ->Write();
  hVtx_YZ->Write();
  hVtxOut_X->Write();
  hVtxOut_Y->Write();
  hVtxOut_Z->Write();
  hVtxOut_XY->Write();
  hVtxOut_XZ->Write();
  hVtxOut_YZ->Write();  
  //
  hForwTPC1TrkPtXY->Write();
  hForwTPC1TrkPtXZ->Write();
  hForwTPC1TrkPtYZ->Write();
  hForwTPC2TrkPtXY->Write();
  hForwTPC2TrkPtXZ->Write();
  hForwTPC2TrkPtYZ->Write();
  hForwTPC3TrkPtXY->Write();
  hForwTPC3TrkPtXZ->Write();
  hForwTPC3TrkPtYZ->Write();
  hTPCUp1TrkPtXY->Write();
  hTPCUp1TrkPtXZ->Write();
  hTPCUp1TrkPtYZ->Write();
  hTPCUp2TrkPtXY->Write();
  hTPCUp2TrkPtXZ->Write();
  hTPCUp2TrkPtYZ->Write();
  hTPCDown1TrkPtXY->Write();
  hTPCDown1TrkPtXZ->Write();
  hTPCDown1TrkPtYZ->Write();
  hTPCDown2TrkPtXY->Write();
  hTPCDown2TrkPtXZ->Write();
  hTPCDown2TrkPtYZ->Write();
  hDsECalTrkPtXY->Write();
  hDsECalTrkPtXZ->Write();
  hDsECalTrkPtYZ->Write();
  hBrlECalTrkPtXY->Write();
  hBrlECalTrkPtXZ->Write();
  hBrlECalTrkPtYZ->Write();
  hP0DECalTrkPtXY->Write();
  hP0DECalTrkPtXZ->Write();
  hP0DECalTrkPtYZ->Write();
  hUSECalP0DTrkPtXY->Write();
  hUSECalP0DTrkPtXZ->Write();
  hUSECalP0DTrkPtYZ->Write();
  hToFDownTrkPtXY->Write();
  hToFDownTrkPtXZ->Write();
  hToFDownTrkPtYZ->Write();
  hToFUpTrkPtXY->Write();
  hToFUpTrkPtXZ->Write();
  hToFUpTrkPtYZ->Write();
  //
  hTimeTarg1_DsECal->Write();
  hTimeTarg1_BrlECal->Write();
  hTimeTarg1_P0DECal->Write();
  hTimeTarg1_USECalP0D->Write();
  hTimeTarg1_ForwTPC1->Write();
  hTimeTarg1_ForwTPC2->Write();
  hTimeTarg1_ForwTPC3->Write();
  hTimeTarg1_TPCUp1->Write();
  hTimeTarg1_TPCUp2->Write();
  hTimeTarg1_TPCDown1->Write();
  hTimeTarg1_TPCDown2->Write();
  hTimeTarg1_ToFTopUp->Write();
  hTimeTarg1_ToFBotUp->Write();
  hTimeTarg1_ToFRightUp->Write();
  hTimeTarg1_ToFLeftUp->Write();
  hTimeTarg1_ToFBackUp->Write();
  hTimeTarg1_ToFFrontUp->Write();
  hTimeTarg1_ToFTopDown->Write();
  hTimeTarg1_ToFBotDown->Write();
  hTimeTarg1_ToFRightDown->Write();
  hTimeTarg1_ToFLeftDown->Write();
  hTimeTarg1_ToFBackDown->Write();
  hTimeTarg1_ToFFrontDown->Write();
  //
  out->Close();
  
  // // Print output
  // cout << endl;
  // cout << "Total # of Tree events: " << NTreeEntries << endl;
  // cout << "Total # of simulated events: " << Nentries << endl;
  // cout << "Select: " << endl;
  // if(doCutCC) cout << " - Select CC events" << endl;
  // if(doCutReac) cout << " - Reac = " << StringReacAll(cut_reac) << endl;
  // if(doCutPDG) cout << " - PDG = " << cut_pdg << endl;
  // if(doCutCharge) cout << " - Charge = " << cut_charge << endl;
  // if(doCutDLTarget)
  //   cout << " - length Target > " << cut_length_target_min << " mm" << endl; 
  // if(doCutDLyzTPC)
  //   cout << " - dLyz TPC > " << cut_dlyz_tpc_min << " mm" << endl;
  // cout << endl;
  // cout << "Total # of vtx after CC cut = " << NTotCC << endl;
  // cout << "Total # of vtx after reaction mode cut = " << NTotVtxReac << endl;
  // cout << "Total # of events in FV = " << NTotEvtFV << endl;
  // cout << "Total # of tracks after PDG cut = " << NTotTrkPassPDG << endl;
  // cout << "Total # of tracks after charge cut = " << NTotTrkPassCharge << endl;
  // cout << "Total # of tracks after std cut = " 
  //      << hCosThetaVsMom_FV->GetEntries() << endl;
  // cout << "Total # of tracks after Target cut = " 
  //      << hCosThetaVsMom_Target->GetEntries() << endl;
  // cout << "Total # of tracks after tpc Lyz cut = " 
  //      << hCosThetaVsMom_TPC->GetEntries() << endl;
  // cout << "Total # of tracks after Target and TPC = "
  //      << hCosThetaVsMom_TargetAndTPC->GetEntries() << endl;
  // cout << "Total # of tracks after Target or TPC = " 
  //      << hCosThetaVsMom_TargetOrTPC->GetEntries() << endl;
  // cout << endl;
  // cout << "Calculate selection efficiencies:" << endl;
  // cout << " - Target only eff = " 
  //      <<  hCosThetaVsMom_Target->GetEntries() / hCosThetaVsMom_FV->GetEntries() 
  //      << endl;
  // cout << " - TPC only eff = " 
  //      <<  hCosThetaVsMom_TPC->GetEntries() / hCosThetaVsMom_FV->GetEntries() 
  //      << endl;
  // cout << " - Target+TPC eff = " 
  //      <<  hCosThetaVsMom_TargetOrTPC->GetEntries() / hCosThetaVsMom_FV->GetEntries() 
  //      << endl;

}





//___________________________________________________________________________ 
bool IsCCQE(int neut_reaction_mode)
{
  return neut_reaction_mode ==  1;
}
//___________________________________________________________________________ 
bool IsCC1pi(int neut_reaction_mode)
{
  bool is_cc1pi = (neut_reaction_mode == 11 ||
                   neut_reaction_mode == 12 ||
                   neut_reaction_mode == 13);
  return is_cc1pi;
}
//___________________________________________________________________________ 
bool IsCCcoh(int neut_reaction_mode)
{
  return neut_reaction_mode ==  16;
}
//___________________________________________________________________________ 
bool Is2p2h(int neut_reaction_mode)
{
  return neut_reaction_mode ==  2;
}
//___________________________________________________________________________
bool IsCCoth(int neut_reaction_mode)                               
{
  bool is_ccoth = (neut_reaction_mode == 17 ||
                     neut_reaction_mode == 21 ||
                     neut_reaction_mode == 22 ||
                     neut_reaction_mode == 23 ||
                     neut_reaction_mode == 26);
  return is_ccoth;
}
//___________________________________________________________________________ 
bool IsNC(int neut_reaction_mode)
{
  bool is_not_nc =  IsCCoth(neut_reaction_mode);
  is_not_nc = Is2p2h(neut_reaction_mode);
  is_not_nc = IsCCcoh(neut_reaction_mode);
  is_not_nc = IsCC1pi(neut_reaction_mode);
  is_not_nc = IsCCQE(neut_reaction_mode);
  
  bool is_nc = !is_not_nc;
  return is_nc;
}
//___________________________________________________________________________ 
int GetReacAll(int neut_reaction_mode){
  if(IsCCQE(neut_reaction_mode)){ 
    return 0;
  }
  else if(Is2p2h(neut_reaction_mode)){ 
    return 1;
  }
  else if(IsCC1pi(neut_reaction_mode)){ 
    return 2;
  }
  else if(IsCCcoh(neut_reaction_mode)){ 
    return 3;
  }
  else if(IsCCoth(neut_reaction_mode)){ 
    return 4;
  }
  else {
    return 5;
  }
}
//___________________________________________________________________________ 
string StringReacAll(int reaction_mode_all){
  if(reaction_mode_all==0){ return "CCQE";}
  else if(reaction_mode_all==1){ return "2p2h";}
  else if(reaction_mode_all==2){ return "CC1pi";}
  else if(reaction_mode_all==3){ return "CCcoh";}
  else if(reaction_mode_all==4){ return "CCOth";}
  else if(reaction_mode_all==5){ return "NC";}
  else {
    cerr << "No Reac mode" << endl;
    cerr << "reaction_mode_all = " << reaction_mode_all << endl;
    exit(1);
  }
}
//___________________________________________________________________________ 
//bool IsTargetIn(int targetID,double x,double y,double z,
bool IsTargetIn(double x,double y,double z,
		// Target 1
		double vtx_min_x_1,
		double vtx_max_x_1,  
		double vtx_min_y_1, 
		double vtx_max_y_1, 
		double vtx_min_z_1,  
		double vtx_max_z_1 
		// Target 2
		//double vtx_min_x_2,  
		//double vtx_max_x_2,  
		//double vtx_min_y_2, 
		//double vtx_max_y_2,  
		//double vtx_min_z_2,
		//double vtx_max_z_2  
){
  
  // Target 1 FV
  //if(targetID==1){
  if((x > vtx_min_x_1 && x < vtx_max_x_1) && 
     (y > vtx_min_y_1 && y < vtx_max_y_1) && 
     (z > vtx_min_z_1 && z < vtx_max_z_1)
     ){
    return true;
  }
  else{
    return false;
  }
  //}	
  // Target 2 FV
  //if(targetID==2){
  //if((x > vtx_min_x_2 && x < vtx_max_x_2) &&
  //(y > vtx_min_y_2 && y < vtx_max_y_2) &&
  //(z > vtx_min_z_2 && z < vtx_max_z_2)
  //){	  
  //return true;
  //}
  //else{
  //return false;
  //}
  //}
  //else{
  //cerr << endl;
  //cerr << "Target ID = " << targetID << " is wrong" << endl;
  //cerr << "You can choose between 1 and 2" << endl;
  //cerr << endl;
  //exit(1);
  //}
}
//___________________________________________________________________________                                                                                                                           
//bool IsTargetIn(int targetID,double x,double y,double z,
//              // Target 1                                                                                                                                                                     
//double vtx_min_x_1,
//double vtx_max_x_1,
//              double vtx_min_y_1,
//              double vtx_max_y_1,
//              double vtx_min_z_1,
//              double vtx_max_z_1,
//              // Target 2                                                                                                                                                                             
//              double vtx_min_x_2,
//              double vtx_max_x_2,
//                double vtx_min_y_2,
//              double vtx_max_y_2,
//                double vtx_min_z_2,
//              double vtx_max_z_2
//		){                                                                                
// Target 1 FV                                                                                                                                                                         
//if(targetID==1){
//    if((x > vtx_min_x_1 && x < vtx_max_x_1) &&
//     (y > vtx_min_y_1 && y < vtx_max_y_1) &&
//       (z > vtx_min_z_1 && z < vtx_max_z_1)
//     ){
//return true;
//  }
//  else{
//    return false;
//  }
//  }
// Target 2 FV                                                                                                                                                                                            
//if(targetID==2){
//  if((x > vtx_min_x_2 && x < vtx_max_x_2) &&
//     (y > vtx_min_y_2 && y < vtx_max_y_2) &&
//     (z > vtx_min_z_2 && z < vtx_max_z_2)
//     ){
//    return true;
//  }
//  else{
//    return false;
//  }
//}
//else{
// cerr << endl;
// cerr << "Target ID = " << targetID << " is wrong" << endl;
//  cerr << "You can choose between 1 and 2" << endl;
//  cerr << endl;
//  exit(1);
//}
//}
//___________________________________________________________________________ 
