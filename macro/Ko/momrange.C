/// Available sensitive detectors (1/2/17):
//
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/DsECal/Module/Active/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/DsECal/Module/Active/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/LeftSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/TopLeftBotRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/LeftSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/LeftSide/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/BotLeftTopRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/RightSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/BotLeftTopRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/RightSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/RightSide/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/TopLeftBotRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCUp1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCUp2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCDown1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCDown2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/Target1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/Target2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontUp/ScintVert/Bar --> Included and same name as corresponding physical volume



#include <TH1D.h>
#include <TH2D.h>
#include <TROOT.h>
#include <TTree.h>
#include <TFile.h>
#include <TMath.h>
#include <TGraph.h>
#include <TF1.h>

#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpHit.hh"
#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrackPoint.hh"
#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrack.hh"
#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpVertex.hh"
#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpEvent.hh"


bool IsTargetIn(double x,double y,double z,
		// Target 1
		double vtx_min_x_1,
		double vtx_max_x_1,  
		double vtx_min_y_1, 
		double vtx_max_y_1, 
		double vtx_min_z_1,  
		double vtx_max_z_1 
		);
bool OOFVCheck_MPPCHits(TH2F *h2D);


void momrange
(
 const int evtfirst = 0,
 const int nevents = 1,
 
 string tag = "outputs/prova",
 
 string infilename = "../bin/ciao.root",




 // Definition of Fiducial Volume for target thickness=60cm (mm)  
 const double vtx_min_x_1 = -950,
 const double vtx_max_x_1 = +950,  
 const double vtx_min_y_1 = -300, 
 const double vtx_max_y_1 = +300, 
 const double vtx_min_z_1 = -1695,  
 const double vtx_max_z_1 = -745, 

 // Cut 0: Select only CC mode
 const bool doCutCC = true,

 // Cut 1: Select reaction mode
 const bool doCutReac = false,
 const int cut_reac = 0, // 0=CCQE, 1=2p2h, 2=CC1pi, 3=CCcoh, 4=CCDIS, 5=NC
 
 // Cut 2: Vertex cut (inside the Targets and FGDs)
 const bool doCutMater = false,
 const bool doCutVtx = true, 
 
 const bool doCutTarget1 = true, // Select vertex in Target1
 const bool doCutTarget2 = false, // Select vertex in Target2
 const bool doCutFGD1 = true, // Select vertex in FGD1
 const bool doCutFGD2 = false, // Select vertex in FGD2 

 const bool doCutVtxX = false, // width
 const double cut_xmin = 0,
 const double cut_xmax = 0,
 
 const bool doCutVtxZ = false, // length
 const double cut_zmin = 0,
 const double cut_zmax = 0,
 
 // Cut 3: Select PDG
 const bool doCutPDG = true,
 const int cut_pdg = 13, //+211, //+2212; //+13; // +211; //+11
 
 // Cut 4: Select parent ID (0 --> it's primary particle)
 const bool doCutParentID = true,
 const int cut_parentID = 0,

 // Cut 5: Charge cut (TPCs and Target)  
 const bool doCutCharge = true,
 const double cut_charge = 1, // absolute value 
 
 // Cut 6: Length cut (Targets) 
 const bool doCutDLTarget = true, // full length in target and dlyz in tpcs    
 const double cut_length_target_min = 50, //mm  
 
 // Cut 7: DeltaLyz cut (TPCs)
 const bool doCutDLyzTPC = true,
 const double cut_dlyz_tpc_min = 200, //mm  

 // Mod: Electron or Gamma
 const int particle = 11,
 const bool useFGDlike = false
 )
{
  // Define histograms

  if (useFGDlike) cout << "Considering FGDlike Target" << endl;

  if(nevents>20000){
    cout << "You cannot use more than 20000 events!!!" << endl;
    exit(1);
  }


  /////////////////////////
  //                     //
  // STUFFS FOR FGD-LIKE //
  //                     //
  /////////////////////////



  TH2F *hMomRange = new TH2F("hMomRange","",200,0.,1600.,200,0.,2000.);
  hMomRange->GetXaxis()->SetTitle("Range (mm)");
  hMomRange->GetYaxis()->SetTitle("Momentum (MeV/c)");

  TH1F *hRange_MeanMom = new TH1F("hRange_MeanMom","",200,0.,1600.);
  hRange_MeanMom->GetXaxis()->SetTitle("Range (mm)");
  hRange_MeanMom->GetYaxis()->SetTitle("Mean Momentum (MeV/c)");
  
  TH1F *hRange = new TH1F("hRange","",200,0.,1600.);
  hRange->GetXaxis()->SetTitle("Range (mm)");
 


  /////////

  TFile *finput = new TFile(infilename.c_str(),"READ");
 
  TTree *tinput = (TTree*) finput->Get("ND280upEvents");
  
  TND280UpEvent *nd280UpEvent = new TND280UpEvent();  
  tinput->SetBranchAddress("Event",&nd280UpEvent);
  
  int NTreeEntries = tinput->GetEntries();  
  int evtlasttree = evtfirst+NTreeEntries-1;
  int Nentries = nevents;
 
  cout << endl;
  cout << "# of entries in the Tree: " << NTreeEntries << endl;
  cout << "last tree event ID: " << evtlasttree << endl;
  cout << "first event ID: " << evtfirst << endl;
  cout << endl;


  int EntryLast = evtfirst+Nentries-1;


  for(int ievt=0;ievt<=EntryLast-evtfirst;ievt++){ // get last entry
    
    tinput->GetEntry(ievt);
   


    /////////////
    vector <double> track_momentum;
    track_momentum.clear();

    vector <double> track_costheta;
    track_costheta.clear();

    vector <double> track_range;
    track_range.clear();

    int NTracks = nd280UpEvent->GetNTracks();

    int NVertices = nd280UpEvent->GetNVertices();
    if(NVertices>1){
      cerr << endl;
      cerr << "More than 1 vertex is not yet supported!!!" << endl;
      cerr << endl;
      exit(1);
    }


    TND280UpVertex *nd280UpVertex;

    bool primary_track = false;
    bool inthetarget = false;

    for(int itrk=0;itrk<NTracks;itrk++){
      
      TND280UpTrack *nd280UpTrack = nd280UpEvent->GetTrack(itrk);
      //            nd280UpTrack->PrintTrack();      
      int trkID = nd280UpTrack->GetTrackID();
      int parentID = nd280UpTrack->GetParentID();
      int pdg = nd280UpTrack->GetPDG();
      double costheta = nd280UpTrack->GetInitCosTheta();
      double charge = nd280UpTrack->GetCharge();
      double ekin = nd280UpTrack->GetInitKinEnergy();
      double mom = nd280UpTrack->GetInitMom().Mag(); 
      double range = nd280UpTrack->GetRange(); 
      string procName = nd280UpTrack->GetProcessName();
      int NPoints = nd280UpTrack->GetNPoints();

      TND280UpTrackPoint *nd280UpTrackPoint_Start = nd280UpTrack->GetPoint(0); 
      double PtX_Start = nd280UpTrackPoint_Start->GetPostPosition().X();
      double PtY_Start = nd280UpTrackPoint_Start->GetPostPosition().Y();
      double PtZ_Start = nd280UpTrackPoint_Start->GetPostPosition().Z();
      double PtMom_Start = nd280UpTrackPoint_Start->GetMomentum().Mag();


      TND280UpTrackPoint *nd280UpTrackPoint_End = nd280UpTrack->GetPoint(NPoints-1); 
      double PtX_End = nd280UpTrackPoint_End->GetPostPosition().X();
      double PtY_End = nd280UpTrackPoint_End->GetPostPosition().Y();
      double PtZ_End = nd280UpTrackPoint_End->GetPostPosition().Z();
      double PtMom_End = nd280UpTrackPoint_End->GetMomentum().Mag();


      if (parentID==0){
	inthetarget = IsTargetIn(PtX_Start,PtY_Start,PtZ_Start,vtx_min_x_1,vtx_max_x_1,vtx_min_y_1,vtx_max_y_1,vtx_min_z_1,vtx_max_z_1);
      }

      if (!inthetarget){
	cout << "Out of Target; rejected."<<endl;
	continue;
      }
  
      if (!primary_track && parentID ==0 && pdg == particle){
	track_momentum.push_back(mom);
	track_costheta.push_back(costheta);
	track_range.push_back(range);
	primary_track = true;
      }

      if (primary_track) break;
    }

    hRange_MeanMom -> Fill(track_range[0], track_momentum[0]);   
    hRange -> Fill(track_range[0]);   

    hMomRange -> Fill(track_range[0], track_momentum[0]);
    delete nd280UpEvent;    
    nd280UpEvent = 0;
  } // end loop over events

 
  
  // Write output file
    TString outfilename = TString::Format("%s_Evt%d_NEvt%d_2DMomResol.root",tag.c_str(),evtfirst,nevents);
  TFile *out = new TFile(outfilename.Data(),"RECREATE");
  //
  

     hMomRange->Write();
     hRange_MeanMom->Write();
     hRange->Write();
     out->Close();
}

//___________________________________________________________________________ 
bool IsTargetIn(double x,double y,double z,
		// Target 1
		double vtx_min_x_1,
		double vtx_max_x_1,  
		double vtx_min_y_1, 
		double vtx_max_y_1, 
		double vtx_min_z_1,  
		double vtx_max_z_1 
		// Target 2
		//double vtx_min_x_2,  
		//double vtx_max_x_2,  
		//double vtx_min_y_2, 
		//double vtx_max_y_2,  
		//double vtx_min_z_2,
		//double vtx_max_z_2  
){
  
  // Target 1 FV
  //if(targetID==1){
  if((x > vtx_min_x_1 && x < vtx_max_x_1) && 
     (y > vtx_min_y_1 && y < vtx_max_y_1) && 
     (z > vtx_min_z_1 && z < vtx_max_z_1)
     ){
    return true;
  }
  else{
    return false;
  }
}
//___________________________________________________________________________ 
bool OOFVCheck_MPPCHits(TH2F *h2D){

  TH1F *hX;
  TH1F *hY;

  hX = (TH1F*) h2D->ProjectionX();
  hY = (TH1F*) h2D->ProjectionY();

  double bincontX_first = hX->GetBinContent(1);
  double bincontX_last  = hX->GetBinContent(hX->GetNbinsX());
  if(bincontX_first>0. || bincontX_last>0.){
    return true;
  }

  double bincontY_first = hY->GetBinContent(1);
  double bincontY_last  = hY->GetBinContent(hY->GetNbinsX());
  if(bincontY_first>0. || bincontY_last>0.){
    return true;
  }
  return false;
}
//___________________________________________________________________________ 
