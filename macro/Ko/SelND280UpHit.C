//
// Available sensitive detectors (1/2/17):
//
//
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/DsECal/Module/Active/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/DsECal/Module/Active/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/LeftSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/TopLeftBotRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/LeftSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/LeftSide/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/BotLeftTopRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/RightSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/BotLeftTopRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/RightSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/RightSide/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/TopLeftBotRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCUp1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCUp2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCDown1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCDown2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/Target1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/Target2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontUp/ScintVert/Bar --> Included and same name as corresponding physical volume



#include <TH1D.h>
#include <TH2D.h>
#include <TROOT.h>
#include <TTree.h>
#include <TFile.h>
#include <TMath.h>

#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpHit.hh"
#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrackPoint.hh"
#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrack.hh"
#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpVertex.hh"
#include "/gpfs/home/t2k/kiwamoto/ND280Upgrade/Software/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpEvent.hh"

int GetReacAll(int neut_reaction_mode);
string StringReacAll(int neut_reaction_mode);
bool IsTargetIn(double x,double y,double z,
		// Target 1
		double vtx_min_x_1,
		double vtx_max_x_1,  
		double vtx_min_y_1, 
		double vtx_max_y_1, 
		double vtx_min_z_1,  
		double vtx_max_z_1 
		);

void SelND280UpHit(
 const int evtfirst = 0,
 const int nevents = 1,
 
 string tag = "outputs/prova",
 
 string infilename = "../bin/ciao.root",

 // Definition of Fiducial Volume for target thickness=60cm (mm)  
 const double vtx_min_x_1 = -1150,
 const double vtx_max_x_1 = +1150,  
 const double vtx_min_y_1 = -300, 
 const double vtx_max_y_1 = +300, 
 const double vtx_min_z_1 = -2487,  
 const double vtx_max_z_1 = -487, 


 // Cut 0: Select only CC mode
 const bool doCutCC = true,

 // Cut 1: Select reaction mode
 const bool doCutReac = false,
 const int cut_reac = 0, // 0=CCQE, 1=2p2h, 2=CC1pi, 3=CCcoh, 4=CCDIS, 5=NC
 
 // Cut 2: Vertex cut (inside the Targets and FGDs)
 const bool doCutMater = false,
 const bool doCutVtx = true, 
 
 const bool doCutTarget1 = true, // Select vertex in Target1
 const bool doCutTarget2 = false, // Select vertex in Target2
 const bool doCutFGD1 = true, // Select vertex in FGD1
 const bool doCutFGD2 = false, // Select vertex in FGD2 

 const bool doCutVtxX = false, // width
 const double cut_xmin = 0,
 const double cut_xmax = 0,
 
 const bool doCutVtxZ = false, // length
 const double cut_zmin = 0,
 const double cut_zmax = 0,
 
 // Cut 3: Select PDG
 const bool doCutPDG = true,
 const int cut_pdg = 13, //+211, //+2212; //+13; // +211; //+11
 
 // Cut 4: Select parent ID (0 --> it's primary particle)
 const bool doCutParentID = true,
 const int cut_parentID = 0,

 // Cut 5: Charge cut (TPCs and Target)  
 const bool doCutCharge = true,
 const double cut_charge = 1, // absolute value 
 
 // Cut 6: Length cut (Targets) 
 const bool doCutDLTarget = true, // full length in target and dlyz in tpcs    
 const double cut_length_target_min = 50, //mm  
 
 // Cut 7: DeltaLyz cut (TPCs)
 const bool doCutDLyzTPC = true,
 const double cut_dlyz_tpc_min = 200 //mm  
 )
{



 // FGD Constants
 //const double EdepToPhotConv_FGD = 70.8; // /MeV  // contains both collection in fiber and edep->gamma conversion
 const double DistMPPCscint_FGD = 41.; // mm
 const double LongCompFrac_FGD = 0.816; // const
 const double LongAtt_FGD = 11926.; // mm
 const double ShortAtt_FGD = 312.; // mm
 //const double DecayLength_FGD = 0.0858; // /mm
 //const double Lbar_FGD = 1864.3; // mm
 //

  if(nevents>1000){
    cout << "You cannot use more than 1000 events!!!" << endl;
    exit(1);
  }

  // Define histograms


  
  const int NEvtDisplTot = nevents; 
  TH2F *hMPPCHits_XY[NEvtDisplTot]; TH2F *hMPPCHits_XZ[NEvtDisplTot]; TH2F *hMPPCHits_YZ[NEvtDisplTot];
  TH2F *hMPPCHits_att_XY[NEvtDisplTot]; TH2F *hMPPCHits_att_XZ[NEvtDisplTot]; TH2F *hMPPCHits_att_YZ[NEvtDisplTot];
  TH2F *hMPPCHitsDelay100ns_XY[NEvtDisplTot]; TH2F *hMPPCHitsDelay100ns_XZ[NEvtDisplTot]; TH2F *hMPPCHitsDelay100ns_YZ[NEvtDisplTot];
  TH2F *hMPPCHitsVsTime_XY[NEvtDisplTot]; TH2F *hMPPCHitsVsTime_XZ[NEvtDisplTot]; TH2F *hMPPCHitsVsTime_YZ[NEvtDisplTot];
  TH2F *hPEVsTime_x[NEvtDisplTot]; TH2F* hPEVsTime_y[NEvtDisplTot]; TH2F* hPEVsTime_z[NEvtDisplTot]; 

  TH1F *hPE_x[NEvtDisplTot]; TH1F* hPE_y[NEvtDisplTot]; TH1F* hPE_z[NEvtDisplTot];

  TH1F *hPE_distMPPC_x[NEvtDisplTot];
  TH1F *hPE_distMPPC_z[NEvtDisplTot];

  TH1F *hPE_distMPPC_att_x[NEvtDisplTot];
  TH1F *hPE_distMPPC_att_z[NEvtDisplTot];

  TH2F *hPEVsTime_tot;
  TH1F *hPE_tot_nom;
  TH1F *hPE_tot_att;

  TH1F *hPE_firsthit_nom_x;
  TH1F *hPE_firsthit_nom_z;
  TH1F *hPE_firsthit_att_x;
  TH1F *hPE_firsthit_att_z;

  TH1F *hPE_avg_distMPPC;


  TH2F *hPE_nom_distMPPC_x;
  TH2F *hPE_nom_distMPPC_z;
  TH2F *hPE_att_distMPPC_x;
  TH2F *hPE_att_distMPPC_z;


  hPE_nom_distMPPC_x = new TH2F("hPE_nom_distMPPC_x","hPE_nom_distMPPC_x",180,0.,1800.,200,0.,200.);
  hPE_nom_distMPPC_z = new TH2F("hPE_nom_distMPPC_z","hPE_nom_distMPPC_z",130,0.,1300.,200,0.,200.);

  hPE_att_distMPPC_x = new TH2F("hPE_att_distMPPC_x","hPE_att_distMPPC_x",180,0.,1800.,200,0.,200.);
  hPE_att_distMPPC_z = new TH2F("hPE_att_distMPPC_z","hPE_att_distMPPC_z",130,0.,1300.,200,0.,200.);

  hPE_tot_nom = new TH1F("hPE_tot_nom","hPE_tot_nom",200,0,200);
  hPE_tot_att = new TH1F("hPE_tot_att","hPE_tot_att",200,0,200);

  hPE_firsthit_nom_x = new TH1F("hPE_firsthit_nom_x","hPE_firsthit_nom_x",200,0,200);
  hPE_firsthit_nom_z = new TH1F("hPE_firsthit_nom_z","hPE_firsthit_nom_z",200,0,200);
  hPE_firsthit_att_x = new TH1F("hPE_firsthit_att_x","hPE_firsthit_att_x",200,0,200);
  hPE_firsthit_att_z = new TH1F("hPE_firsthit_att_z","hPE_firsthit_att_z",200,0,200);


  hPE_avg_distMPPC = new TH1F("hPE_avg_distMPPC","hPE_avg_distMPPC",100,0.,1000.);



  hPEVsTime_tot = new TH2F("hPEVsTime_tot","hPEVsTime_tot",200,0,200,40,0,20);


  TFile *finput = new TFile(infilename.c_str(),"READ");

  // Take 2D projection histograms with MPPC hits 

  TH2F* h2d_xy; TH2F* h2d_xz; TH2F* h2d_yz;
  h2d_xy = (TH2F*)finput->Get("OutMPPCProj2D_XY");
  h2d_xz = (TH2F*)finput->Get("OutMPPCProj2D_XZ");
  h2d_yz = (TH2F*)finput->Get("OutMPPCProj2D_YZ");

  /*
  for(int ievtdispl=0;ievtdispl<NEvtDisplTot;ievtdispl++){
    TString name;
    name = TString::Format("hMPPCHits_XY_%d",ievtdispl);
    hMPPCHits_XY[ievtdispl] = (TH2F*)h2d_xy->Clone(name);
    name = TString::Format("hMPPCHits_XZ_%d",ievtdispl);
    hMPPCHits_XZ[ievtdispl] = (TH2F*)h2d_xz->Clone(name);
    name = TString::Format("hMPPCHits_YZ_%d",ievtdispl);
    hMPPCHits_YZ[ievtdispl] = (TH2F*)h2d_yz->Clone(name);
    name = TString::Format("hMPPCHitsDelay100ns_XY_%d",ievtdispl);
    hMPPCHitsDelay100ns_XY[ievtdispl] = (TH2F*)h2d_xy->Clone(name);
    name = TString::Format("hMPPCHitsDelay100ns_XZ_%d",ievtdispl);
    hMPPCHitsDelay100ns_XZ[ievtdispl] = (TH2F*)h2d_xz->Clone(name);
    name = TString::Format("hMPPCHitsDelay100ns_YZ_%d",ievtdispl);
    hMPPCHitsDelay100ns_YZ[ievtdispl] = (TH2F*)h2d_yz->Clone(name);
    name = TString::Format("hMPPCHitsVsTime_XY_%d",ievtdispl);
    hMPPCHitsVsTime_XY[ievtdispl] = (TH2F*)h2d_xy->Clone(name);
    name = TString::Format("hMPPCHitsVsTime_XZ_%d",ievtdispl);
    hMPPCHitsVsTime_XZ[ievtdispl] = (TH2F*)h2d_xz->Clone(name);
    name = TString::Format("hMPPCHitsVsTime_YZ_%d",ievtdispl);
    hMPPCHitsVsTime_YZ[ievtdispl] = (TH2F*)h2d_yz->Clone(name);
    name = TString::Format("hPEVsTime_x_%d",ievtdispl);
    hPEVsTime_x[ievtdispl] = new TH1F(name,name,2000,0,20000);
    name = TString::Format("hPEVsTime_y_%d",ievtdispl);
    hPEVsTime_y[ievtdispl] = new TH1F(name,name,2000,0,20000);
    name = TString::Format("hPEVsTime_z_%d",ievtdispl);
    hPEVsTime_z[ievtdispl] = new TH1F(name,name,2000,0,20000);    
  }
  */

  //
  
  TTree *tinput = (TTree*) finput->Get("ND280upEvents");
  
  TND280UpEvent *nd280UpEvent = new TND280UpEvent();  
  tinput->SetBranchAddress("Event",&nd280UpEvent);
  
  int NTreeEntries = tinput->GetEntries();  
  int evtlasttree = evtfirst+NTreeEntries-1;
  int Nentries = nevents;

  cout << endl;
  cout << "# of entries in the Tree: " << NTreeEntries << endl;
  cout << "last tree event ID: " << evtlasttree << endl;
  cout << "first event ID: " << evtfirst << endl;
    cout << endl;

    /*
  if(evtfirst > evtlasttree){
    cout << endl;
    cout << "first selection evt ID > first evt ID of tree:" << endl;
    cout << " - # of tree events = " << NTreeEntries << endl;
    cout << " - last tree event = " << evtlasttree << endl;
    cout << " - first event = " << evtfirst << endl;
    cout << "Exit!!!" << endl;
    cout << endl;
    exit(1);
  }
  else if(NTreeEntries < (evtfirst+nevents)){
    
    Nentries = NTreeEntries - evtfirst;
    
    cout << endl;
    cout << "WARNING:" << endl;
    cout << "first evt ID + # of events > tot # of tree events:" << endl;
    cout << " - # of tree events = " << NTreeEntries << endl;
    cout << " - # of events to run = " << nevents << endl;
    cout << " - first event = " << evtfirst << endl;
    cout << "Set # of events to run to " << Nentries;
    cout << endl;
  }
  else{
    Nentries = nevents;    
  }
    */

  int EntryLast = evtfirst+Nentries-1;
  
  cout << endl;
  cout << "First event = " << evtfirst << endl;
  cout << "Last event = " << EntryLast << endl;
  cout << "# of events = " << Nentries << endl;
  cout << endl;


  //int NEvtWithHit = 0;

  for(int ievt=evtfirst-evtfirst;ievt<=EntryLast-evtfirst;ievt++){ // get last entry
    
    //if(NEvtWithHit>=NEvtDisplTot) break;
    
    cout << endl;
    cout << "Event " << ievt << endl;
    
    tinput->GetEntry(ievt);

    // Initialize the histograms

    TString name;
    name = TString::Format("hMPPCHits_XY_%d",ievt);
    hMPPCHits_XY[ievt] = (TH2F*)h2d_xy->Clone(name);
    name = TString::Format("hMPPCHits_XZ_%d",ievt);
    hMPPCHits_XZ[ievt] = (TH2F*)h2d_xz->Clone(name);
    name = TString::Format("hMPPCHits_YZ_%d",ievt);
    hMPPCHits_YZ[ievt] = (TH2F*)h2d_yz->Clone(name);
    //    hMPPCHits_YZ[ievt] = new TH2F(name,name,130,-650.,650,60,-300.,300.);

    name = TString::Format("hMPPCHits_att_XY_%d",ievt);
    hMPPCHits_att_XY[ievt] = (TH2F*)h2d_xy->Clone(name);
    name = TString::Format("hMPPCHits_att_XZ_%d",ievt);
    hMPPCHits_att_XZ[ievt] = (TH2F*)h2d_xz->Clone(name);
    name = TString::Format("hMPPCHits_att_YZ_%d",ievt);
        hMPPCHits_att_YZ[ievt] = (TH2F*)h2d_yz->Clone(name);
    //    hMPPCHits_att_YZ[ievt] = new TH2F(name,name,130,-650.,650,60,-300.,300.);
 
    name = TString::Format("hMPPCHitsDelay100ns_XY_%d",ievt);
    hMPPCHitsDelay100ns_XY[ievt] = (TH2F*)h2d_xy->Clone(name);
    name = TString::Format("hMPPCHitsDelay100ns_XZ_%d",ievt);
    hMPPCHitsDelay100ns_XZ[ievt] = (TH2F*)h2d_xz->Clone(name);
    name = TString::Format("hMPPCHitsDelay100ns_YZ_%d",ievt);
     hMPPCHitsDelay100ns_YZ[ievt] = (TH2F*)h2d_yz->Clone(name);
    //hMPPCHitsDelay100ns_YZ[ievt] = new TH2F(name,name,130,-650.,650,60,-300.,300.);

    //name = TString::Format("hMPPCHitsVsTime_XY_%d",ievt);
    //hMPPCHitsVsTime_XY[ievt] = (TH2F*)h2d_xy->Clone(name);
    //name = TString::Format("hMPPCHitsVsTime_XZ_%d",ievt);
    //hMPPCHitsVsTime_XZ[ievt] = (TH2F*)h2d_xz->Clone(name);
    //name = TString::Format("hMPPCHitsVsTime_YZ_%d",ievt);
    //hMPPCHitsVsTime_YZ[ievt] = (TH2F*)h2d_yz->Clone(name);

    name = TString::Format("hPEVsTime_x_%d",ievt);
    hPEVsTime_x[ievt] = new TH2F(name,name,200,0,200,40,0,20);
    name = TString::Format("hPEVsTime_y_%d",ievt);
    hPEVsTime_y[ievt] = new TH2F(name,name,200,0,200,40,0,20);
    name = TString::Format("hPEVsTime_z_%d",ievt);
    hPEVsTime_z[ievt] = new TH2F(name,name,200,0,200,40,0,20);    


    name = TString::Format("hPE_x_%d",ievt);
    hPE_x[ievt] = new TH1F(name,name,200,0,200);
    name = TString::Format("hPE_y_%d",ievt);
    hPE_y[ievt] = new TH1F(name,name,200,0,200);
    name = TString::Format("hPE_z_%d",ievt);
    hPE_z[ievt] = new TH1F(name,name,200,0,200);

  
    name = TString::Format("hPE_distMPPC_x_%d",ievt);
    hPE_distMPPC_x[ievt] = new TH1F(name,name,180,0.,1800.);

    name = TString::Format("hPE_distMPPC_z_%d",ievt);
    hPE_distMPPC_z[ievt] = new TH1F(name,name,130,0.,1300.);

    name = TString::Format("hPE_distMPPC_x_att_%d",ievt);
    hPE_distMPPC_att_x[ievt] = new TH1F(name,name,180,0.,1800.);

    name = TString::Format("hPE_distMPPC_att_z_%d",ievt);
    hPE_distMPPC_att_z[ievt] = new TH1F(name,name,130,0.,1300.);
 

    // Loop over the tracks
    
    int NTracks = nd280UpEvent->GetNTracks();
    
    cout << "# of tracks = " << NTracks << endl;
    
    for(int itrk=0;itrk<NTracks;itrk++){
      TND280UpTrack *nd280UpTrack = nd280UpEvent->GetTrack(itrk);
      // nd280UpTrack->PrintTrack();
      int trkID = nd280UpTrack->GetTrackID();
      int parentID = nd280UpTrack->GetParentID();
      int pdg = nd280UpTrack->GetPDG();
      double charge = nd280UpTrack->GetCharge();
      double ekin = nd280UpTrack->GetInitKinEnergy();
      double mom = nd280UpTrack->GetInitMom().Mag(); 

      TND280UpTrackPoint *nd280UpTrackPoint = nd280UpTrack->GetPoint(0); 
      string volname = nd280UpTrackPoint->GetLogVolName();
      cout << "trkID: " << trkID << ", pdg: " << pdg << ", det: " << volname << endl;
    }

  
    // Loop over the hits in the target
    
    int NHits = nd280UpEvent->GetNHits();

    //cout << "Event " << ievt << ", EventWithHit " << NEvtWithHit << endl;  
    cout << "# of hits = " << nd280UpEvent->GetNHits() << endl;

    //if(NHits>0) NEvtWithHit++;
    
    int current_pdg = 0;

      double pe_nom_tot[3] = {0.,0.,0};
      double pe_att_tot[3] = {0.,0.,0};

      bool firsttosecondlayer = false;
      bool insecondlayer = false;
      double initmppcx = 5.;
      double initmppcy = 5.;
      double initmppcz = 5.;

      double initpex = 0.;
      double initpey = 0.;
      double initpez = 0.;
      double initpex_att = 0.;
      double initpey_att = 0.;
      double initpez_att = 0.;

    for(int ihit=0;ihit<NHits;ihit++){ // get last entry

      TND280UpHit *nd280UpHit = nd280UpEvent->GetHit(ihit);
      //      nd280UpHit->PrintHit();

      double wposx = nd280UpHit->GetPosX();
      double wposy = nd280UpHit->GetPosY();
      double wposz = nd280UpHit->GetPosZ();      

      double locposx = nd280UpHit->GetLocPosX();
      double locposy = nd280UpHit->GetLocPosY();
      double locposz = nd280UpHit->GetLocPosZ();

      double loclgtx = nd280UpHit->GetLocLgtX();
      double loclgty = nd280UpHit->GetLocLgtY();
      double loclgtz = nd280UpHit->GetLocLgtZ();

      double mppcx = nd280UpHit->GetMPPCLocPosX();
      double mppcy = nd280UpHit->GetMPPCLocPosY();
      double mppcz = nd280UpHit->GetMPPCLocPosZ();

      double wmppcx = nd280UpHit->GetMPPCPosX();
      double wmppcy = nd280UpHit->GetMPPCPosY();
      double wmppcz = nd280UpHit->GetMPPCPosZ();
      
      double dmppcx = nd280UpHit->GetDistMPPCX();
      double dmppcy = nd280UpHit->GetDistMPPCY();
      double dmppcz = nd280UpHit->GetDistMPPCZ();

      int trackID = nd280UpHit->GetTrackID();
      


      if (ihit==0) 
	{
	  initmppcx = mppcx;
	  initmppcy = mppcy;
	  initmppcz = mppcz;
	}

      int pdg = nd280UpHit->GetPDG();
      
      double pex = nd280UpHit->GetPEX(); // along X
      double pey = nd280UpHit->GetPEY(); // along Y
      double pez = nd280UpHit->GetPEZ(); // along Z

      //TEST 06262017
      //  cout << "Det: " << nd280UpHit->GetDetName()<< endl;
      //cout << "P.E (x,y,z) = " << pex << ", " << pey << ", " << pez << endl;
      double a = LongCompFrac_FGD;
      double d = DistMPPCscint_FGD;
      double LongAtt = LongAtt_FGD;
      double ShortAtt = ShortAtt_FGD;


      //      double pex_att = pex * ( a*exp((-dmppcx-d)/LongAtt) + (1.-a)*exp((-dmppcx-d)/ShortAtt) ); // along X, w/ fiber attn
      //      double pey_att = pey * ( a*exp((-dmppcy-d)/LongAtt) + (1.-a)*exp((-dmppcy-d)/ShortAtt) ); // along Y, w/ fiber attn
      //      double pez_att = pez * ( a*exp((-dmppcz-d)/LongAtt) + (1.-a)*exp((-dmppcz-d)/ShortAtt) ); // along Z, w/ fiber attn

      double pex_att = pex * ( a*exp((-dmppcx-d)/LongAtt) + (1.-a)*exp((-dmppcx-d)/ShortAtt) ); // along X, w/ fiber attn
      double pey_att = pey * ( a*exp((-dmppcy-d)/LongAtt) + (1.-a)*exp((-dmppcy-d)/ShortAtt) ); // along Y, w/ fiber attn
      double pez_att = pez * ( a*exp((-dmppcz-d)/LongAtt) + (1.-a)*exp((-dmppcz-d)/ShortAtt) ); // along Z, w/ fiber attn

      /*
      if (pex >2.5) pe_nom_tot[0] += pex;
      if (pey >2.5) pe_nom_tot[1] += pey;
      if (pez >2.5) pe_nom_tot[2] += pez;

      if (pex_att >2.5) pe_att_tot[0] += pex_att;
      if (pey_att >2.5) pe_att_tot[1] += pey_att;
      if (pez_att >2.5) pe_att_tot[2] += pez_att;
      */
      //

      double time_x = nd280UpHit->GetTimePEX(); // # of pe Vs time
      double time_y = nd280UpHit->GetTimePEY(); // # of pe Vs time
      double time_z = nd280UpHit->GetTimePEZ(); // # of pe Vs time
      /*
      if (TMath::Abs(mppcx-loclgtx)>4.75 || TMath::Abs(mppcy-loclgty)>4.75 || TMath::Abs(mppcz-loclgtz)>4.75 ) 
	{
	  cout << "pseudo-FV cut applied" << endl;
	  continue;
	}
      */




      if (trackID != 1) 

	{
	  cout << "NOT PRIMARY ID!" <<endl;
	  continue;
	}
      /*
           cout << "MPPC (x,y,z) = " << mppcx << ", " << mppcy << ", " << mppcz << endl;
           cout << "P.E (x,y,z) = " << pex << ", " << pey << ", " << pez << endl;
	   cout << "LGT (x,y,z) = " << loclgtx << ", " << loclgty << ", " << loclgtz << endl;
           cout << "P.E w/ fiber attenuation (x,y,z) = " << pex_att << ", " << pey_att << ", " << pez_att << endl;
	   cout << "DMPPC (x,y,z) = " << dmppcx << ", " << dmppcy << ", " << dmppcz << endl;
	   cout << endl;
      */

      //      if (pex_att<2.5 && pez_att==0.0 ) continue;
      // if (pez_att<2.5 && pex_att==0.0 ) continue;

      /*
      if ((mppcx == initmppcx && mppcy == initmppcy && mppcz == initmppcz) && !firsttosecondlayer)
	{

            cout << "Starting Layer Hit: " << ihit <<endl;
      //            cout << time_x << ", " << time_y << ", " << time_z << endl;
      //    cout << pex << " " << pey << " " << pez << endl;
           cout << "MPPC (x,y,z) = " << mppcx << ", " << mppcy << ", " << mppcz << endl;
           cout << "P.E (x,y,z) = " << pex << ", " << pey << ", " << pez << endl;
           cout << "P.E w/ fiber attenuation (x,y,z) = " << pex_att << ", " << pey_att << ", " << pez_att << endl;
	   cout << "LGT (x,y,z) = " << loclgtx << ", " << loclgty << ", " << loclgtz << endl;
	   cout << "Pos (x,y,z) = " << locposx << ", " << locposy << ", " << locposz << endl;
	   cout << "WPos (x,y,z) = " << wposx << ", " << wposy << ", " << wposz << endl;
	   cout << "WMPPC (x,y,z) = " << wmppcx << ", " << wmppcy << ", " << wmppcz << endl;
	   cout << "DMPPC (x,y,z) = " << dmppcx << ", " << dmppcy << ", " << dmppcz << endl;
	   cout << endl;
	}
      */

      
      
      if ( (mppcx != initmppcx || mppcy != initmppcy || mppcz != initmppcz) && !firsttosecondlayer )
	{
	  firsttosecondlayer = true;
	  insecondlayer = true;

	  initmppcx = mppcx;
	  initmppcy = mppcy;
	  initmppcz = mppcz;
	  //        cout << "(Transition to second layer) Hit: " << ihit <<endl;
      //            cout << time_x << ", " << time_y << ", " << time_z << endl;
      //    cout << pex << " " << pey << " " << pez << endl;
	  //    cout << "MPPC (x,y,z) = " << mppcx << ", " << mppcy << ", " << mppcz << endl;
	  //  cout << "P.E (x,y,z) = " << pex << ", " << pey << ", " << pez << endl;
	  //  cout << "P.E w/ fiber attenuation (x,y,z) = " << pex_att << ", " << pey_att << ", " << pez_att << endl;
	  // cout << "LGT (x,y,z) = " << loclgtx << ", " << loclgty << ", " << loclgtz << endl;
	  //  cout << "Pos (x,y,z) = " << locposx << ", " << locposy << ", " << locposz << endl;
	  // cout << "WPos (x,y,z) = " << wposx << ", " << wposy << ", " << wposz << endl;
	  //  cout << "WMPPC (x,y,z) = " << wmppcx << ", " << wmppcy << ", " << wmppcz << endl;
	  //  cout << "DMPPC (x,y,z) = " << dmppcx << ", " << dmppcy << ", " << dmppcz << endl;
	  //  cout<<endl;
	}


      if(pdg!=current_pdg){
	current_pdg = pdg;      
	cout << pdg << endl;
      }
      
      
      if ( (mppcx == initmppcx && mppcy == initmppcy && mppcz == initmppcz) && insecondlayer)
	{
          //  cout << "Second Layer Hit: " << ihit <<endl;
      //            cout << time_x << ", " << time_y << ", " << time_z << endl;
      //    cout << pex << " " << pey << " " << pez << endl;
          // cout << "MPPC (x,y,z) = " << mppcx << ", " << mppcy << ", " << mppcz << endl;
          // cout << "P.E (x,y,z) = " << pex << ", " << pey << ", " << pez << endl;
          // cout << "P.E w/ fiber attenuation (x,y,z) = " << pex_att << ", " << pey_att << ", " << pez_att << endl;
	  //  cout << "LGT (x,y,z) = " << loclgtx << ", " << loclgty << ", " << loclgtz << endl;
	   //  cout << "Pos (x,y,z) = " << locposx << ", " << locposy << ", " << locposz << endl;
	  //  cout << "WPos (x,y,z) = " << wposx << ", " << wposy << ", " << wposz << endl;
	  //  cout << "WMPPC (x,y,z) = " << wmppcx << ", " << wmppcy << ", " << wmppcz << endl;
	  //  cout << "DMPPC (x,y,z) = " << dmppcx << ", " << dmppcy << ", " << dmppcz << endl;
	  //  cout<<endl;      
//      cout << "LGT (x,y,z) = " << lgtx << ", " << lgty << ", " << lgtz << endl;
	  initpex += pex;
	  initpey += pey;
	  initpez += pez;
	  initpex_att += pex_att;
	  initpey_att += pey_att;
	  initpez_att += pez_att;
	}

      
      if ( (mppcx != initmppcx || mppcy != initmppcy || mppcz != initmppcz) && insecondlayer )
	{
	  insecondlayer = false;
	  //            cout << "(End of Second Layer) Hit: " << ihit <<endl;
      //            cout << time_x << ", " << time_y << ", " << time_z << endl;
      //    cout << pex << " " << pey << " " << pez << endl;
	  //   cout << "MPPC (x,y,z) = " << mppcx << ", " << mppcy << ", " << mppcz << endl;
	  //  cout << "P.E (x,y,z) = " << pex << ", " << pey << ", " << pez << endl;
	  //  cout << "P.E w/ fiber attenuation (x,y,z) = " << pex_att << ", " << pey_att << ", " << pez_att << endl;
	  //  cout << "LGT (x,y,z) = " << loclgtx << ", " << loclgty << ", " << loclgtz << endl;
	  //  cout << "Pos (x,y,z) = " << locposx << ", " << locposy << ", " << locposz << endl;
	  ///  cout << "WPos (x,y,z) = " << wposx << ", " << wposy << ", " << wposz << endl;
	  //  cout << "WMPPC (x,y,z) = " << wmppcx << ", " << wmppcy << ", " << wmppcz << endl;
	  //  cout << "DMPPC (x,y,z) = " << dmppcx << ", " << dmppcy << ", " << dmppcz << endl;
	  // cout<<endl;
      //      cout << "LGT (x,y,z) = " << lgtx << ", " << lgty << ", " << lgtz << endl;
	} 
      

      if (ihit == (NHits-1))
	{ 
	  //	  cout << "Last Hit: " << ihit << ", NHits = " << NHits<<endl;
	  //  cout << "P.E (x,y,z) = " << initpex << ", " << initpey << ", " << initpez << endl;
	  hPE_firsthit_nom_x->Fill(initpex);
	  hPE_firsthit_nom_z->Fill(initpez);
	  hPE_firsthit_att_x->Fill(initpex_att);
	  hPE_firsthit_att_z->Fill(initpez_att);
	}

      //int ievtWithHit = NEvtWithHit-1;
      hMPPCHits_XY[ievt]->Fill(mppcx,mppcy,pez); // pe along Z
      hMPPCHits_XZ[ievt]->Fill(mppcx,mppcz,pey); // pe along Y
      hMPPCHits_YZ[ievt]->Fill(mppcy,mppcz,pex); // pe along X

      hMPPCHits_att_XY[ievt]->Fill(mppcx,mppcy,pez_att); // pe along Z
      hMPPCHits_att_XZ[ievt]->Fill(mppcx,mppcz,pey_att); // pe along Y
      hMPPCHits_att_YZ[ievt]->Fill(mppcy,mppcz,pex_att); // pe along X

      //Att Study
      hPE_distMPPC_att_x[ievt]->Fill(dmppcx,pex_att);
      hPE_distMPPC_x[ievt]->Fill(dmppcx,pex);

      hPE_distMPPC_att_z[ievt]->Fill(dmppcz,pez_att);
      hPE_distMPPC_z[ievt]->Fill(dmppcz,pez);
      
      //double binX = hMPPCHits_XY[ievt]->GetXaxis()->FindBin(mppcx);
      double binY = hMPPCHits_YZ[ievt]->GetXaxis()->FindBin(mppcy);
      //  double binZ = hMPPCHits_YZ[ievt]->GetYaxis()->FindBin(mppcz);

      if ((mppcy/ hMPPCHits_YZ[ievt]->GetXaxis()->GetBinCenter(binY)) !=1.)cout << "binY = " << mppcy << " / " << hMPPCHits_YZ[ievt]->GetXaxis()->GetBinCenter(binY) << endl;




      //hMPPCHitsVsTime_XY[ievt]->Fill(mppcx,mppcy,time_z); // pe along X
      //hMPPCHitsVsTime_XZ[ievt]->Fill(mppcx,mppcz,time_y); // pe along Y
      //hMPPCHitsVsTime_YZ[ievt]->Fill(mppcy,mppcz,time_x); // pe along Z 

      if(time_x > 100) hMPPCHitsDelay100ns_XY[ievt]->Fill(mppcx,mppcy,pez); // pe along X
      if(time_y > 100) hMPPCHitsDelay100ns_XZ[ievt]->Fill(mppcx,mppcz,pey); // pe along Y
      if(time_z > 100) hMPPCHitsDelay100ns_YZ[ievt]->Fill(mppcy,mppcz,pex); // pe along Z 

      hPEVsTime_x[ievt]->Fill(time_x,pex);
      hPEVsTime_y[ievt]->Fill(time_y,pey);
      hPEVsTime_z[ievt]->Fill(time_z,pez);

      hPEVsTime_tot->Fill(time_x,pex);
      hPEVsTime_tot->Fill(time_y,pey);
      hPEVsTime_tot->Fill(time_z,pez);    

    }

    //NOM

    for(int i=0;i<hPE_distMPPC_x[ievt]->GetXaxis()->GetNbins();i++){
	double pedx = hPE_distMPPC_x[ievt]->GetBinContent(i+1);
	if (pedx > 2.5) 
	  {
	    //  hPE_tot_nom->Fill(pex);
	    hPE_nom_distMPPC_x->Fill(hPE_distMPPC_x[ievt]->GetXaxis()->GetBinCenter(i+1),pedx);
	    cout << "bin: DistMPPC_x = " << hPE_distMPPC_x[ievt]->GetXaxis()->GetBinCenter(i+1) << ", pe/bar = " << pedx <<endl;
	  }	
    }
    for(int i=0;i<hPE_distMPPC_z[ievt]->GetXaxis()->GetNbins();i++){
	double pedz = hPE_distMPPC_z[ievt]->GetBinContent(i+1);
	if (pedz > 2.5) 
	  {
	    //hPE_tot_nom->Fill(pez);
	    hPE_nom_distMPPC_z->Fill(hPE_distMPPC_z[ievt]->GetXaxis()->GetBinCenter(i+1),pedz);
	    cout << "bin: DistMPPC_z = " << hPE_distMPPC_z[ievt]->GetXaxis()->GetBinCenter(i+1) << ", pe/bar = " << pedz <<endl;
	  }
    }

    //ATT

    for(int i=0;i<hPE_distMPPC_att_x[ievt]->GetXaxis()->GetNbins();i++){
	double pedx = hPE_distMPPC_att_x[ievt]->GetBinContent(i+1);
	if (pedx > 2.5) 
	  {
	    // hPE_tot_att->Fill(pex);
	    hPE_att_distMPPC_x->Fill(hPE_distMPPC_att_x[ievt]->GetXaxis()->GetBinCenter(i+1),pedx);
	    // cout << "att bin: " << hPE_distMPPC_att_x[ievt]->GetXaxis()->GetBinCenter(i+1) << ", pex/bar = " << pex <<endl;
	  }	
    }
    for(int i=0;i<hPE_distMPPC_att_z[ievt]->GetXaxis()->GetNbins();i++){
	double pedz = hPE_distMPPC_att_z[ievt]->GetBinContent(i+1);
	if (pedz > 2.5) 
	  {
	    //hPE_tot_att->Fill(pez);
	    hPE_att_distMPPC_z->Fill(hPE_distMPPC_att_z[ievt]->GetXaxis()->GetBinCenter(i+1),pedz);
	    //	      cout << "bin: " << hPE_distMPPC_att_z[ievt]->GetXaxis()->GetBinCenter(i+1) << ", pez/bar = " << pez <<endl;
	  }
    }


  


    for(int i=0;i<hMPPCHits_XY[ievt]->GetXaxis()->GetNbins();i++){
      for(int j=0;j<hMPPCHits_XY[ievt]->GetYaxis()->GetNbins();j++){
	double pe = hMPPCHits_XY[ievt]->GetBinContent(i+1,j+1);
		if (pe >2.5){
	  hPE_z[ievt]->Fill(pe);
	  //	  hPE_tot_nom->Fill(pe);
	  	}
      }
    }
    for(int i=0;i<hMPPCHits_XZ[ievt]->GetXaxis()->GetNbins();i++){
      for(int j=0;j<hMPPCHits_XZ[ievt]->GetYaxis()->GetNbins();j++){
	  double pe = hMPPCHits_XZ[ievt]->GetBinContent(i+1,j+1);
	   if (pe > 2.5){
	  hPE_y[ievt]->Fill(pe);
	  /// hPE_tot_nom->Fill(pe);
	   }
      }
    }   
    for(int i=0;i<hMPPCHits_YZ[ievt]->GetXaxis()->GetNbins();i++){
      for(int j=0;j<hMPPCHits_YZ[ievt]->GetYaxis()->GetNbins();j++){
        double pe = hMPPCHits_YZ[ievt]->GetBinContent(i+1,j+1);
		if (pe > 2.5){
	  hPE_x[ievt]->Fill(pe);
	  hPE_tot_nom->Fill(pe);
	  	}
      }
    }


    

    for(int i=0;i<hMPPCHits_att_XY[ievt]->GetXaxis()->GetNbins();i++){
      for(int j=0;j<hMPPCHits_att_XY[ievt]->GetYaxis()->GetNbins();j++){
	double pe = hMPPCHits_att_XY[ievt]->GetBinContent(i+1,j+1);
		if (pe >2.5){
		  // hPE_z[ievt]->Fill(pe);
		  //	  hPE_tot_att->Fill(pe);
	  	}
      }
    }
    for(int i=0;i<hMPPCHits_att_XZ[ievt]->GetXaxis()->GetNbins();i++){
      for(int j=0;j<hMPPCHits_att_XZ[ievt]->GetYaxis()->GetNbins();j++){
	  double pe = hMPPCHits_att_XZ[ievt]->GetBinContent(i+1,j+1);
	   if (pe > 2.5){
	     // hPE_y[ievt]->Fill(pe);
	     //  hPE_tot_att->Fill(pe);
	   }
      }
    }   
    for(int i=0;i<hMPPCHits_att_YZ[ievt]->GetXaxis()->GetNbins();i++){
      for(int j=0;j<hMPPCHits_att_YZ[ievt]->GetYaxis()->GetNbins();j++){
        double pe = hMPPCHits_att_YZ[ievt]->GetBinContent(i+1,j+1);
		if (pe > 2.5){
		  //hPE_x[ievt]->Fill(pe);
		    hPE_tot_att->Fill(pe);
	  	}
      }
    }


    
    //nd280UpEvent->PrintEvent();
    
    // Fill event histograms

    delete nd280UpEvent;    
    nd280UpEvent = 0;
  } // end loop over events

  // Write output file
  TString outfilename = TString::Format("%s_Evt%d_NEvt%d.root",tag.c_str(),evtfirst,nevents);
  TFile *out = new TFile(outfilename.Data(),"RECREATE");
  //



  //for(int ievtdispl=0;ievtdispl<NEvtWithHit;ievtdispl++){    
  //for(int ievtdispl=0;ievtdispl<NEvtDisplTot;ievtdispl++){    
  for(int ievtdispl=evtfirst-evtfirst;ievtdispl<=EntryLast-evtfirst;ievtdispl++){ // get last entry
    hMPPCHits_XY[ievtdispl]->Write();  
    hMPPCHits_XZ[ievtdispl]->Write();  
    hMPPCHits_YZ[ievtdispl]->Write();

    //hMPPCHitsVsTime_XY[ievtdispl]->Write();  
    //hMPPCHitsVsTime_XZ[ievtdispl]->Write();  
    //hMPPCHitsVsTime_YZ[ievtdispl]->Write();

    hMPPCHitsDelay100ns_XY[ievtdispl]->Write();  
    hMPPCHitsDelay100ns_XZ[ievtdispl]->Write();  
    hMPPCHitsDelay100ns_YZ[ievtdispl]->Write();

    hPEVsTime_x[ievtdispl]->Write(); 
    hPEVsTime_y[ievtdispl]->Write(); 
    hPEVsTime_z[ievtdispl]->Write(); 
    
    hPE_x[ievtdispl]->Write();
    hPE_y[ievtdispl]->Write();
    hPE_z[ievtdispl]->Write();

    hPE_distMPPC_x[ievtdispl]->Write();
    hPE_distMPPC_z[ievtdispl]->Write();

    hPE_distMPPC_att_x[ievtdispl]->Write();
    hPE_distMPPC_att_z[ievtdispl]->Write();


  }
  hPE_nom_distMPPC_x->Write();
  hPE_nom_distMPPC_z->Write();
  hPE_att_distMPPC_x->Write();
  hPE_att_distMPPC_z->Write();

  hPE_firsthit_nom_x->Write();
  hPE_firsthit_nom_z->Write();
  hPE_firsthit_att_x->Write();
  hPE_firsthit_att_z->Write();

  hPE_tot_nom->Write();
  hPE_tot_att->Write();
  //
  finput->Close();
  out->Close();
}





//___________________________________________________________________________ 
bool IsCCQE(int neut_reaction_mode)
{
  return neut_reaction_mode ==  1;
}
//___________________________________________________________________________ 
bool IsCC1pi(int neut_reaction_mode)
{
  bool is_cc1pi = (neut_reaction_mode == 11 ||
                   neut_reaction_mode == 12 ||
                   neut_reaction_mode == 13);
  return is_cc1pi;
}
//___________________________________________________________________________ 
bool IsCCcoh(int neut_reaction_mode)
{
  return neut_reaction_mode ==  16;
}
//___________________________________________________________________________ 
bool Is2p2h(int neut_reaction_mode)
{
  return neut_reaction_mode ==  2;
}
//___________________________________________________________________________
bool IsCCoth(int neut_reaction_mode)                               
{
  bool is_ccoth = (neut_reaction_mode == 17 ||
                     neut_reaction_mode == 21 ||
                     neut_reaction_mode == 22 ||
                     neut_reaction_mode == 23 ||
                     neut_reaction_mode == 26);
  return is_ccoth;
}
//___________________________________________________________________________ 
bool IsNC(int neut_reaction_mode)
{
  bool is_not_nc =  IsCCoth(neut_reaction_mode);
  is_not_nc = Is2p2h(neut_reaction_mode);
  is_not_nc = IsCCcoh(neut_reaction_mode);
  is_not_nc = IsCC1pi(neut_reaction_mode);
  is_not_nc = IsCCQE(neut_reaction_mode);
  
  bool is_nc = !is_not_nc;
  return is_nc;
}
//___________________________________________________________________________ 
int GetReacAll(int neut_reaction_mode){
  if(IsCCQE(neut_reaction_mode)){ 
    return 0;
  }
  else if(Is2p2h(neut_reaction_mode)){ 
    return 1;
  }
  else if(IsCC1pi(neut_reaction_mode)){ 
    return 2;
  }
  else if(IsCCcoh(neut_reaction_mode)){ 
    return 3;
  }
  else if(IsCCoth(neut_reaction_mode)){ 
    return 4;
  }
  else {
    return 5;
  }
}
//___________________________________________________________________________ 
string StringReacAll(int reaction_mode_all){
  if(reaction_mode_all==0){ return "CCQE";}
  else if(reaction_mode_all==1){ return "2p2h";}
  else if(reaction_mode_all==2){ return "CC1pi";}
  else if(reaction_mode_all==3){ return "CCcoh";}
  else if(reaction_mode_all==4){ return "CCOth";}
  else if(reaction_mode_all==5){ return "NC";}
  else {
    cerr << "No Reac mode" << endl;
    cerr << "reaction_mode_all = " << reaction_mode_all << endl;
    exit(1);
  }
}
//___________________________________________________________________________ 
//bool IsTargetIn(int targetID,double x,double y,double z,
bool IsTargetIn(double x,double y,double z,
		// Target 1
		double vtx_min_x_1,
		double vtx_max_x_1,  
		double vtx_min_y_1, 
		double vtx_max_y_1, 
		double vtx_min_z_1,  
		double vtx_max_z_1 
		// Target 2
		//double vtx_min_x_2,  
		//double vtx_max_x_2,  
		//double vtx_min_y_2, 
		//double vtx_max_y_2,  
		//double vtx_min_z_2,
		//double vtx_max_z_2  
){
  
  // Target 1 FV
  //if(targetID==1){
  if((x > vtx_min_x_1 && x < vtx_max_x_1) && 
     (y > vtx_min_y_1 && y < vtx_max_y_1) && 
     (z > vtx_min_z_1 && z < vtx_max_z_1)
     ){
    return true;
  }
  else{
    return false;
  }
  //}	
  // Target 2 FV
  //if(targetID==2){
  //if((x > vtx_min_x_2 && x < vtx_max_x_2) &&
  //(y > vtx_min_y_2 && y < vtx_max_y_2) &&
  //(z > vtx_min_z_2 && z < vtx_max_z_2)
  //){	  
  //return true;
  //}
  //else{
  //return false;
  //}
  //}
  //else{
  //cerr << endl;
  //cerr << "Target ID = " << targetID << " is wrong" << endl;
  //cerr << "You can choose between 1 and 2" << endl;
  //cerr << endl;
  //exit(1);
  //}
}
//___________________________________________________________________________                                                                                                                           
//bool IsTargetIn(int targetID,double x,double y,double z,
//              // Target 1                                                                                                                                                                     
//double vtx_min_x_1,
//double vtx_max_x_1,
//              double vtx_min_y_1,
//              double vtx_max_y_1,
//              double vtx_min_z_1,
//              double vtx_max_z_1,
//              // Target 2                                                                                                                                                                             
//              double vtx_min_x_2,
//              double vtx_max_x_2,
//                double vtx_min_y_2,
//              double vtx_max_y_2,
//                double vtx_min_z_2,
//              double vtx_max_z_2
//		){                                                                                
// Target 1 FV                                                                                                                                                                         
//if(targetID==1){
//    if((x > vtx_min_x_1 && x < vtx_max_x_1) &&
//     (y > vtx_min_y_1 && y < vtx_max_y_1) &&
//       (z > vtx_min_z_1 && z < vtx_max_z_1)
//     ){
//return true;
//  }
//  else{
//    return false;
//  }
//  }
// Target 2 FV                                                                                                                                                                                            
//if(targetID==2){
//  if((x > vtx_min_x_2 && x < vtx_max_x_2) &&
//     (y > vtx_min_y_2 && y < vtx_max_y_2) &&
//     (z > vtx_min_z_2 && z < vtx_max_z_2)
//     ){
//    return true;
//  }
//  else{
//    return false;
//  }
//}
//else{
// cerr << endl;
// cerr << "Target ID = " << targetID << " is wrong" << endl;
//  cerr << "You can choose between 1 and 2" << endl;
//  cerr << endl;
//  exit(1);
//}
//}
//___________________________________________________________________________ 
