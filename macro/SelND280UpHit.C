//
// Available sensitive detectors (1/2/17):
//
//
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/X/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/P0D/USECal/P0Dule/Y/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/DsECal/Module/Active/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/DsECal/Module/Active/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/LeftSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/P0DECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/TopLeftBotRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/LeftSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/LeftSide/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/LeftClam/BrlECal/BotLeftTopRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/RightSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/P0DECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/BotLeftTopRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/BotLeftTopRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/RightSide/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/RightSide/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/TopLeftBotRight/Active/ScintPara/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/RightClam/BrlECal/TopLeftBotRight/Active/ScintPerp/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC1/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC2/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/Half --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ForwTPC3/MM --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCUp1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCUp2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCDown1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/TPCDown2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/Target1 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/Target2 --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontDown/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontDown/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/TopUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BotUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/RightUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/LeftUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/BackUp/ScintVert/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontUp/ScintHoriz/Bar --> Included and same name as corresponding physical volume
// /t2k/OA/Magnet/Basket/ToF/FrontUp/ScintVert/Bar --> Included and same name as corresponding physical volume



#include <TH1D.h>
#include <TH2D.h>
#include <TROOT.h>
#include <TTree.h>
#include <TFile.h>
#include <TMath.h>

#include "/atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpHit.hh"
#include "/atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrackPoint.hh"
#include "/atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpTrack.hh"
#include "/atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpVertex.hh"
#include "/atlas/users/dsgalabe/t2k-nd280-upgrade/src/app/nd280UpEvent/TND280UpEvent.hh"

int GetReacAll(int neut_reaction_mode);
string StringReacAll(int neut_reaction_mode);
bool IsTargetIn(double x,double y,double z,
		// Target 1
		double vtx_min_x_1,
		double vtx_max_x_1,  
		double vtx_min_y_1, 
		double vtx_max_y_1, 
		double vtx_min_z_1,  
		double vtx_max_z_1 
		);

void SelND280UpHit
(
 const int evtfirst = 0,
 const int nevents = 1,
 
 string tag = "outputs/prova",
 
 string infilename = "../bin/ciao.root",

 // Definition of Fiducial Volume for target thickness=60cm (mm)  
 const double vtx_min_x_1 = -1150,
 const double vtx_max_x_1 = +1150,  
 const double vtx_min_y_1 = -300, 
 const double vtx_max_y_1 = +300, 
 const double vtx_min_z_1 = -2487,  
 const double vtx_max_z_1 = -487, 

 // Cut 0: Select only CC mode
 const bool doCutCC = true,

 // Cut 1: Select reaction mode
 const bool doCutReac = false,
 const int cut_reac = 0, // 0=CCQE, 1=2p2h, 2=CC1pi, 3=CCcoh, 4=CCDIS, 5=NC
 
 // Cut 2: Vertex cut (inside the Targets and FGDs)
 const bool doCutMater = false,
 const bool doCutVtx = true, 
 
 const bool doCutTarget1 = true, // Select vertex in Target1
 const bool doCutTarget2 = false, // Select vertex in Target2
 const bool doCutFGD1 = true, // Select vertex in FGD1
 const bool doCutFGD2 = false, // Select vertex in FGD2 

 const bool doCutVtxX = false, // width
 const double cut_xmin = 0,
 const double cut_xmax = 0,
 
 const bool doCutVtxZ = false, // length
 const double cut_zmin = 0,
 const double cut_zmax = 0,
 
 // Cut 3: Select PDG
 const bool doCutPDG = true,
 const int cut_pdg = 13, //+211, //+2212; //+13; // +211; //+11
 
 // Cut 4: Select parent ID (0 --> it's primary particle)
 const bool doCutParentID = true,
 const int cut_parentID = 0,

 // Cut 5: Charge cut (TPCs and Target)  
 const bool doCutCharge = true,
 const double cut_charge = 1, // absolute value 
 
 // Cut 6: Length cut (Targets) 
 const bool doCutDLTarget = true, // full length in target and dlyz in tpcs    
 const double cut_length_target_min = 50, //mm  
 
 // Cut 7: DeltaLyz cut (TPCs)
 const bool doCutDLyzTPC = true,
 const double cut_dlyz_tpc_min = 200 //mm  
 
 )
{
  // Define histograms
  
  const int NEvtDisplTot = 50; 
  TH2F *hMPPCHits_XY[NEvtDisplTot]; TH2F *hMPPCHits_XZ[NEvtDisplTot]; TH2F *hMPPCHits_YZ[NEvtDisplTot];
  
  //

  TFile *finput = new TFile(infilename.c_str(),"READ");

  // Take 2D projection histograms with MPPC hits 

  TH2F* h2d_xy; TH2F* h2d_xz; TH2F* h2d_yz;
  h2d_xy = (TH2F*)finput->Get("OutMPPCProj2D_XY");
  h2d_xz = (TH2F*)finput->Get("OutMPPCProj2D_XZ");
  h2d_yz = (TH2F*)finput->Get("OutMPPCProj2D_YZ");
  
  for(int ievtdispl=0;ievtdispl<NEvtDisplTot;ievtdispl++){
    TString name;
    name = TString::Format("hMPPCHits_XY_%d",ievtdispl);
    hMPPCHits_XY[ievtdispl] = (TH2F*)h2d_xy->Clone(name);
    name = TString::Format("hMPPCHits_XZ_%d",ievtdispl);
    hMPPCHits_XZ[ievtdispl] = (TH2F*)h2d_xz->Clone(name);
    name = TString::Format("hMPPCHits_YZ_%d",ievtdispl);
    hMPPCHits_YZ[ievtdispl] = (TH2F*)h2d_yz->Clone(name);
  }
  //
  
  TTree *tinput = (TTree*) finput->Get("ND280upEvents");
  
  TND280UpEvent *nd280UpEvent = new TND280UpEvent();  
  tinput->SetBranchAddress("Event",&nd280UpEvent);
  
  int NTreeEntries = tinput->GetEntries();  
  int evtlasttree = NTreeEntries-1;
  int Nentries = -999;

  cout << endl;
  cout << "# of entries in the Tree: " << NTreeEntries << endl;
  cout << "last tree event ID: " << evtlasttree << endl;
  cout << "first event ID: " << evtfirst << endl;
  cout << endl;
  
  if(evtfirst > evtlasttree){
    cout << endl;
    cout << "first selection evt ID > first evt ID of tree:" << endl;
    cout << " - # of tree events = " << NTreeEntries << endl;
    cout << " - last tree event = " << evtlasttree << endl;
    cout << " - first event = " << evtfirst << endl;
    cout << "Exit!!!" << endl;
    cout << endl;
    exit(1);
  }
  else if(NTreeEntries < (evtfirst+nevents)){
    
    Nentries = NTreeEntries - evtfirst;
    
    cout << endl;
    cout << "WARNING:" << endl;
    cout << "first evt ID + # of events > tot # of tree events:" << endl;
    cout << " - # of tree events = " << NTreeEntries << endl;
    cout << " - # of events to run = " << nevents << endl;
    cout << " - first event = " << evtfirst << endl;
    cout << "Set # of events to run to " << Nentries;
    cout << endl;
  }
  else{
    Nentries = nevents;    
  }
  
  int EntryLast = evtfirst+Nentries-1;
  
  cout << endl;
  cout << "First event = " << evtfirst << endl;
  cout << "Last event = " << EntryLast << endl;
  cout << "# of events = " << Nentries << endl;
  cout << endl;


  int NEvtWithHit = 0;

  for(int ievt=evtfirst;ievt<=EntryLast;ievt++){ // get last entry
    
    if(NEvtWithHit>=NEvtDisplTot) break;
    
    tinput->GetEntry(ievt);
    
    cout << "Event " << ievt << ", EventWithHit " << NEvtWithHit << endl;
    
    int NHits = nd280UpEvent->GetNHits();

    cout << "# of hits = " << nd280UpEvent->GetNHits() << endl;

    if(NHits>0) NEvtWithHit++;
    
    for(int ihit=0;ihit<NHits;ihit++){ // get last entry
      
      TND280UpHit *nd280UpHit = nd280UpEvent->GetHit(ihit);
      //nd280UpHit->PrintHit();
      
      double mppcx = nd280UpHit->GetLocPosX();
      double mppcy = nd280UpHit->GetLocPosY();
      double mppcz = nd280UpHit->GetLocPosZ();

      double pex = nd280UpHit->GetPEX(); // along X
      double pey = nd280UpHit->GetPEY(); // along Y
      double pez = nd280UpHit->GetPEZ(); // along Z

      //cout << pex << " " << pey << " " << pez << endl;
      //cout << mppcx << " " << mppcy << " " << mppcz << endl;

      int ievtWithHit = NEvtWithHit-1;
      hMPPCHits_XY[ievtWithHit]->Fill(mppcx,mppcy,pez); // pe along X
      hMPPCHits_XZ[ievtWithHit]->Fill(mppcx,mppcz,pey); // pe along Y
      hMPPCHits_YZ[ievtWithHit]->Fill(mppcy,mppcz,pex); // pe along Z 
    }

    //nd280UpEvent->PrintEvent();
    
    // Fill event histograms

    delete nd280UpEvent;    
    nd280UpEvent = 0;
  } // end loop over events

  // Write output file
  TString outfilename = TString::Format("%s_Evt%d_NEvt%d.root",tag.c_str(),evtfirst,nevents);
  TFile *out = new TFile(outfilename.Data(),"RECREATE");
  //
  for(int ievtdispl=0;ievtdispl<NEvtWithHit;ievtdispl++){    
    hMPPCHits_XY[ievtdispl]->Write();  
    hMPPCHits_XZ[ievtdispl]->Write();  
    hMPPCHits_YZ[ievtdispl]->Write();
  }
  //
  out->Close();
 
}





//___________________________________________________________________________ 
bool IsCCQE(int neut_reaction_mode)
{
  return neut_reaction_mode ==  1;
}
//___________________________________________________________________________ 
bool IsCC1pi(int neut_reaction_mode)
{
  bool is_cc1pi = (neut_reaction_mode == 11 ||
                   neut_reaction_mode == 12 ||
                   neut_reaction_mode == 13);
  return is_cc1pi;
}
//___________________________________________________________________________ 
bool IsCCcoh(int neut_reaction_mode)
{
  return neut_reaction_mode ==  16;
}
//___________________________________________________________________________ 
bool Is2p2h(int neut_reaction_mode)
{
  return neut_reaction_mode ==  2;
}
//___________________________________________________________________________
bool IsCCoth(int neut_reaction_mode)                               
{
  bool is_ccoth = (neut_reaction_mode == 17 ||
                     neut_reaction_mode == 21 ||
                     neut_reaction_mode == 22 ||
                     neut_reaction_mode == 23 ||
                     neut_reaction_mode == 26);
  return is_ccoth;
}
//___________________________________________________________________________ 
bool IsNC(int neut_reaction_mode)
{
  bool is_not_nc =  IsCCoth(neut_reaction_mode);
  is_not_nc = Is2p2h(neut_reaction_mode);
  is_not_nc = IsCCcoh(neut_reaction_mode);
  is_not_nc = IsCC1pi(neut_reaction_mode);
  is_not_nc = IsCCQE(neut_reaction_mode);
  
  bool is_nc = !is_not_nc;
  return is_nc;
}
//___________________________________________________________________________ 
int GetReacAll(int neut_reaction_mode){
  if(IsCCQE(neut_reaction_mode)){ 
    return 0;
  }
  else if(Is2p2h(neut_reaction_mode)){ 
    return 1;
  }
  else if(IsCC1pi(neut_reaction_mode)){ 
    return 2;
  }
  else if(IsCCcoh(neut_reaction_mode)){ 
    return 3;
  }
  else if(IsCCoth(neut_reaction_mode)){ 
    return 4;
  }
  else {
    return 5;
  }
}
//___________________________________________________________________________ 
string StringReacAll(int reaction_mode_all){
  if(reaction_mode_all==0){ return "CCQE";}
  else if(reaction_mode_all==1){ return "2p2h";}
  else if(reaction_mode_all==2){ return "CC1pi";}
  else if(reaction_mode_all==3){ return "CCcoh";}
  else if(reaction_mode_all==4){ return "CCOth";}
  else if(reaction_mode_all==5){ return "NC";}
  else {
    cerr << "No Reac mode" << endl;
    cerr << "reaction_mode_all = " << reaction_mode_all << endl;
    exit(1);
  }
}
//___________________________________________________________________________ 
//bool IsTargetIn(int targetID,double x,double y,double z,
bool IsTargetIn(double x,double y,double z,
		// Target 1
		double vtx_min_x_1,
		double vtx_max_x_1,  
		double vtx_min_y_1, 
		double vtx_max_y_1, 
		double vtx_min_z_1,  
		double vtx_max_z_1 
		// Target 2
		//double vtx_min_x_2,  
		//double vtx_max_x_2,  
		//double vtx_min_y_2, 
		//double vtx_max_y_2,  
		//double vtx_min_z_2,
		//double vtx_max_z_2  
){
  
  // Target 1 FV
  //if(targetID==1){
  if((x > vtx_min_x_1 && x < vtx_max_x_1) && 
     (y > vtx_min_y_1 && y < vtx_max_y_1) && 
     (z > vtx_min_z_1 && z < vtx_max_z_1)
     ){
    return true;
  }
  else{
    return false;
  }
  //}	
  // Target 2 FV
  //if(targetID==2){
  //if((x > vtx_min_x_2 && x < vtx_max_x_2) &&
  //(y > vtx_min_y_2 && y < vtx_max_y_2) &&
  //(z > vtx_min_z_2 && z < vtx_max_z_2)
  //){	  
  //return true;
  //}
  //else{
  //return false;
  //}
  //}
  //else{
  //cerr << endl;
  //cerr << "Target ID = " << targetID << " is wrong" << endl;
  //cerr << "You can choose between 1 and 2" << endl;
  //cerr << endl;
  //exit(1);
  //}
}
//___________________________________________________________________________                                                                                                                           
//bool IsTargetIn(int targetID,double x,double y,double z,
//              // Target 1                                                                                                                                                                     
//double vtx_min_x_1,
//double vtx_max_x_1,
//              double vtx_min_y_1,
//              double vtx_max_y_1,
//              double vtx_min_z_1,
//              double vtx_max_z_1,
//              // Target 2                                                                                                                                                                             
//              double vtx_min_x_2,
//              double vtx_max_x_2,
//                double vtx_min_y_2,
//              double vtx_max_y_2,
//                double vtx_min_z_2,
//              double vtx_max_z_2
//		){                                                                                
// Target 1 FV                                                                                                                                                                         
//if(targetID==1){
//    if((x > vtx_min_x_1 && x < vtx_max_x_1) &&
//     (y > vtx_min_y_1 && y < vtx_max_y_1) &&
//       (z > vtx_min_z_1 && z < vtx_max_z_1)
//     ){
//return true;
//  }
//  else{
//    return false;
//  }
//  }
// Target 2 FV                                                                                                                                                                                            
//if(targetID==2){
//  if((x > vtx_min_x_2 && x < vtx_max_x_2) &&
//     (y > vtx_min_y_2 && y < vtx_max_y_2) &&
//     (z > vtx_min_z_2 && z < vtx_max_z_2)
//     ){
//    return true;
//  }
//  else{
//    return false;
//  }
//}
//else{
// cerr << endl;
// cerr << "Target ID = " << targetID << " is wrong" << endl;
//  cerr << "You can choose between 1 and 2" << endl;
//  cerr << endl;
//  exit(1);
//}
//}
//___________________________________________________________________________ 
